<!DOCTYPE html>
<html xml:lang="zh-Hans" xmlns="http://www.w3.org/1999/xhtml" style="font-size: 13pt;">
<head>
    <title>Less and more - Lemo语言 0.1.0</title>
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/base.css" type="text/css" />
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/simplified-chinese-modern.css" type="text/css" />
    <style type="text/css"><![CDATA[
        table {
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
        p > code {
            background-color: rgb(224,224,224);
            padding-left: 0.2em;
            padding-right: 0.2em;
        }
        pre {
            border-left: 0.6em solid rgb(224,224,224);
            padding: 0.25em 1em;
        }
    ]]></style>
    <script src="http://zizisoft.com/doc-html.js" type="text/javascript" />
</head>
<body>
<h1>Less and more - Lemo语言 0.1.0</h1>
<p>詹臻臻 zhanzhenzhen@hotmail.com</p>
<h2>引言</h2>
<p>JavaScript实在是一门很怪的语言。它早年加入了很多无用的功能，不幸的是，出于兼容性考虑，这些功能永远都不能被删掉。另一方面，JavaScript却缺少很多真正有用的功能。当然，刚刚发布的 ECMAScript 6th 补足了大部分缺少的东西，但代价是显得臃肿不堪。如果有一门新的语言，它只继承JavaScript最精华的部分呢？JavaScript最精华的部分是什么？我觉得JSON肯定包括在内，其他的就不多了。下面介绍Lemo语言，它编写的代码可以被JS调用。但反过来则不尽相同，如果使用了激进编译选项，那么大部分传统JS无法被Lemo代码所调用。但如果使用兼容选项，那么可以双向调用。</p>
<pre><code><![CDATA[
    a: [] # var a = []
    a.0: "hello" # a[0] = "hello"
    a.1: "world" # a[1] = "world"
    b: 100
    a.(b): "last" # a[b] = "last"

    b: {}
    b.scheme: "https"
    b."content-length": 123 # b["content-length"] = 123

    c: <> Math.random() # var c = function() { return Math.random(); }
]]></code></pre>
<h2>文件格式与外观</h2>
<p>后缀名为.lemo。</p>
<p>Lemo文件的外观：由版本行、语句、注释和无语义空白组成。语句是可以嵌套的。版本行和语句是有语义的，注释和无语义空白都是无语义的。</p>
<p>语句不是表达式，也不可以作为表达式。表达式不是语句，但可以作为语句，作为语句时称作表达式语句。有两种语句：表达式语句和命令语句。</p>
<p>类似CoffeeScript，在Lemo中，缩进是很重要的，它构成了嵌套。缩进可以用<code>&lt;&lt;</code>与<code>&gt;&gt;</code>代替。</p>
<p>类似CoffeeScript，多个并列的行可以通过分号<code>;</code>合并，单行可以通过<code>\</code>拆分成多行。</p>
<p>空行，是指不含有字符的行。</p>
<p>空白行，是指不含有字符或只含有空白字符的行。</p>
<p>无语义空白，是指空白行，或者行右侧无意义的空白。</p>
<p>下文的所有描述，都是假设代码中的无语义空白已被去除。</p>
<p>大多数语句都是表达式语句，除了这些是命令语句：</p>
<ul>
    <li>:（冒号，表示赋值时）</li>
    <li>delete</li>
    <li>export（仅限于语句开头是export，所以不包括export as，但包括export...as）</li>
    <li>throw</li>
</ul>
<p>给定一条语句，该语句所在级别的最大范围连续内容称作该语句所在的块，块不包括版本行。我们说某语句的子块，是指该语句的一级下属。我们说某块的子语句，也是指该块的一级下属。若某类语句的子块的子项可以是语句或注释，我们称这类子块是语句块。否则，称这类子块是非语句块。</p>
<p>这些块是语句块：</p>
<ul>
    <li>顶级块</li>
    <li>函数块</li>
    <li>then块</li>
    <li>else块</li>
    <li>try块</li>
    <li>catch块</li>
    <li>finally块</li>
</ul>
<p>其他块则都是非语句块，例如：</p>
<ul>
    <li>class块</li>
    <li>数组块</li>
    <li>对象块</li>
    <li>match块</li>
</ul>
<p>所有可以出现语句块的地方，都可以被替换为不嵌套的一条语句而仍然符合语法（有时需要加一个用来分隔的标志）。例如：</p>
<pre><code><![CDATA[
    if x = 5
        aaa()
        bbb()
        ccc()
]]></code></pre>
<p>这是合法的。如果我们把它替换成非块的形式：</p>
<pre><code><![CDATA[
    if x = 5 then aaa()
]]></code></pre>
<p>仍然符合语法。<code>aaa()</code>是<code>if</code>语句的子语句，没有“块”这一层。</p>
<p>语句块的子语句是从上往下执行。除顶级块外所有语句块都有值，若最后一个子语句是表达式，则为该表达式的值，若不是，则为<code>void</code>。</p>
<h2>缩进</h2>
<p>对于某一行B，若它的起始部分不属于字符串，它的缩进的效果是什么？依下面的步骤：</p>
<p>1. 强制连接：上一行A以<code>\</code>结尾吗？若否，则做下一步。若是，则执行：无论缩进如何，该行被解析为犹如被连接到上一行末尾并跳到5，若无法解析则跳到6。（术语解释：这些步骤中的“连接”指的是两行相连，中间插入一空格。第二行的缩进不算入字符。）</p>
<p>2. 并列：上面存在一行A，满足B的缩进等于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接（术语解释：“被连接者”是指连接后的右面，“连接者”是指左面）吗？若否，则做下一步。若是，则执行：A的起始部分和B的起始部分被解析为并列关系并跳到5，若无法解析则跳到4。</p>
<p>3. 层级：上面存在一行A，满足B的缩进大于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接吗？若否，则做下一步。若是，则执行：A的结尾部分和B的起始部分被解析为层级关系并跳到5，若无法解析则跳到4。</p>
<p>4. 连接：上面存在一行A，满足B的缩进不小于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进吗？若否，则跳到6。若是，则执行：B被解析为犹如被连接到A的末尾所属语句的末尾并跳到5，若无法解析则跳到6。例如：</p>
<pre><code><![CDATA[
    if x = 5 and
    y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5
    and y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5 and
        y = 5 then aaa()
]]></code></pre>
<p>都等价于：</p>
<pre><code><![CDATA[
    if x = 5 and y = 5 then aaa()
]]></code></pre>
<p>又例如：</p>
<pre><code><![CDATA[
    a.b <>
        aaa()
    .c()
]]></code></pre>
<p>等价于：</p>
<pre><code><![CDATA[
    a.b(<> aaa()).c()
]]></code></pre>
<p>5. 解析成功并退出。</p>
<p>6. 解析失败并退出。</p>
<p>缩进的规则很适合用来表示一些复杂的语句。例如，你可以这样写：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match (<>
        s = @toLowerCase()
        text.includes(s)
    )
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>和CoffeeScript有一点不同，如下代码：</p>
<pre><code><![CDATA[
    a.b aaa
    .c()
]]></code></pre>
<p>CoffeeScript编译成<code>a.b(aaa).c()</code>，但我们还是按常规编译成<code>a.b(aaa.c())</code>。如果你想要达到CoffeeScript的效果，要加上括号：</p>
<pre><code><![CDATA[
    a.b(aaa)
    .c()
]]></code></pre>
<h2>版本行</h2>
<p>每个文件的第一行必须是版本行。版本行通常都写成一行，但写成多行也是允许的，但为了方便说明，还是说成“版本行”。版本行的一般语法：</p>
<pre><code><![CDATA[
    [...][lemo][...] [-]0.1.0[, (radical | compatible) | (slow new | fast new | manual new) | (node import | node export | node module | es module)]...
]]></code></pre>
<p>默认值为：</p>
<pre><code><![CDATA[
    compatible, fast new, es module
]]></code></pre>
<p>版本号后面的以逗号分隔的项不可重复。版本行的例子：</p>
<pre><code><![CDATA[
    0.1.0
    lemo 0.1.0
    lemo -0.1.0
    0.1.0, node module
    0.1.0, compatible, fast new
    0.1.0, compatible, fast new, node import
    0.1.0, radical, slow new
]]></code></pre>
<p>版本号必须写上。只要你写的版本号不大于安装的Lemo的版本号，该文件就会按照该版本的规范来运行，这是因为你安装的任何一个版本的Lemo都包括了（至少我们会尽量包括）所有历史版本的编译器。而这，是Lemo和其他语言的不同之处。你甚至可以在一个项目中，不同文件使用不同版本。</p>
<p>写上版本号还有个好处，就是你把某个文件交给别人时，他就知道文件是什么版本的，从而可以更好地修改。</p>
<p>本文只描述一个版本。</p>
<p>当你想把版本行写成多行时，版本号后面要加上大括号，大括号必须在第一行。版本号和大括号之间可以有逗号，也可以没有逗号。例如：</p>
<pre><code><![CDATA[
    0.1.0 {
        radical
        node module
    }
]]></code></pre>
<p>多行应用于Shebang的例子（在Shebang中要加选项的话多行是必须的）：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0 {
        radical
        node module
    }
]]></code></pre>
<p>单行应用于Shebang的例子：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0
]]></code></pre>
<p>当文件的后缀名不是.lemo或没有后缀名时，版本号前必须有<code>lemo</code>。当文件的后缀名是.lemo时，不必须，然而我们推荐加上<code>lemo</code>，因为对你的文本编辑器有用，方便它判断应该使用哪个语法包，使代码呈现正确的彩色。</p>
<p>激进模式和兼容模式的差异是：激进模式只允许单参数的函数（多参数和零参数都不允许），兼容模式没有这个限制。因此：</p>
<p>激进模式中，<code>@</code>表示JS的<code>arguments[0]</code>。兼容模式中，<code>@</code>表示JS的<code>arguments</code>。</p>
<p>激进模式中，定义或调用零参数的函数会实际使用单参数<code>void</code>（即JavaScript的<code>undefined</code>）。但兼容模式中，定义或调用零参数的函数会实际使用零参数。例如：激进模式中，<code>a()</code>会被编译成<code>a(undefined)</code>。兼容模式中，<code>a()</code>会被编译成<code>a()</code>。</p>
<p>激进模式中，定义或调用多参数的函数会产生编译错误。但兼容模式中，不会出错。</p>
<p>激进模式中，管道操作符把数组单参数分隔为两部分，而兼容模式中管道操作符把所有参数分隔为两部分。</p>
<p>激进模式中，<code>'</code>只能是二元的，而兼容模式中<code>'</code>还可以是一元的。</p>
<p>下文中，为求简便，如果写道“无参数”，也可指激进模式中的参数为<code>void</code>的情形。</p>
<p><code>fast new</code>是指创建类的实例不用加<code>new</code>，编译时会自动加进去，依据类名的首字母大小写，大写的加，小写的不加。但只能识别普通的表示法，像引号内的就不能识别，例如：</p>
<pre><code><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>slow new</code>是指创建类的实例不用加<code>new</code>，编译时也不会自动加进去，而是在运行时自动判断，依据它是不是es6的class或Lemo的类，是的加，不是的不加。因为运行时判断比较慢（尤其是判断是否是es6的class时只能先尝试不加然后看是不是出错，用到了try-catch，更慢），所以谨慎使用。而且它无法照顾到用普通函数写的类。</p>
<p><code>manual new</code>就是传统办法，创建类的实例需要加<code>new</code>。</p>
<p><code>node import</code>是指导入被编译成node的导入（即require）。<code>node export</code>是指导出被编译成node的导出（即exports和module.exports）。<code>node module</code>是两者都做。<code>es module</code>是两者都不做（即按照ES6的规范）。</p>
<p>编译后的代码是strict mode。</p>
<p>本文的示例是按照兼容模式写的，在激进模式下有些地方需要改写。</p>
<h2>函数</h2>
<p>函数的声明有3种方式：<code>-&gt;</code>、<code>&lt;&gt;</code>、<code>--</code>。<code>&lt;&gt;</code>和<code>--</code>是无参数时的简便方法。参数为1个时括号可省略，这有别于CoffeeScript。</p>
<pre><code><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>如果没有参数，那么必须使用如下一种：</p>
<pre><code><![CDATA[
    a: <> Math.random()
    a: -- Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>兼容模式允许多参数，但必须要有括号：</p>
<pre><code><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>单参数如果是数组的话，可以使用类似解构赋值的形式：</p>
<pre><code><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p>激进模式不支持多参数，如果你想达到多参数的效果怎么办？就可以采用上面例子的方式。注意，当传递的参数不是数组时（例如是<code>void</code>），或者传递的参数个数为零时，它不会出错，而是将x和y都设为<code>void</code>。</p>
<p>在<code>&lt;&gt;</code>函数内部，可以使用<code>@</code>。<code>@</code>取代了JS的<code>arguments</code>（兼容模式下）或<code>arguments[0]</code>（激进模式下），它是如此简便，在许多情况下，你会喜欢不带参数名。例如，我们可以写：</p>
<pre><code><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>参数可以有默认值：</p>
<pre><code><![CDATA[
    a: (x ifvoid: 0, y ifvoid: 0) -> x * y
]]></code></pre>
<p>有默认值的话，参数必须有括号。</p>
<p>如果是<code>ifvoid</code>默认，则<code>ifvoid</code>可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (x: 0, y: 0) -> x * y
]]></code></pre>
<p><code>&lt;&gt;</code>和<code>--</code>的区别是：<code>&lt;&gt;</code>只是没有形参，<code>--</code>是既没形参也没实参，当然严格来讲可以传递实参，但不会有任何效果，因为<code>--</code>没有定义<code>@</code>。<code>--</code>里面可以出现<code>@</code>，但是是指外层<code>&lt;&gt;</code>函数的<code>@</code>。<code>--</code>可以看成是<code>() -&gt;</code>的简写。</p>
<table>
    <tr>
        <th></th>
        <th>-&gt;</th>
        <th>&lt;&gt;</th>
        <th>--</th>
    </tr>
    <tr>
        <td>形参</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>@</td>
        <td>无</td>
        <td>有</td>
        <td>无</td>
    </tr>
    <tr>
        <td>功能</td>
        <td>较多</td>
        <td>最多，可以模拟其他两个</td>
        <td>少</td>
    </tr>
    <tr>
        <td>简洁</td>
        <td>较简洁</td>
        <td>通常很简洁，但有时不简洁</td>
        <td>很简洁</td>
    </tr>
</table>
<p>函数的调用有4种表示法：空格、小括号、中括号、大括号。</p>
<pre><code><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5) # only valid in compatible mode
]]></code></pre>
<p>多参数调用一定要加括号，这个CoffeeScript不同。只有单参数调用是可以不加括号的，零参数要加<code>()</code>。</p>
<p>CoffeeScript里面如果函数调用要传递的参数本身也是函数的话，如果它没有参数，那么可写成<code>abc -&gt; Math.random()</code>，但Lemo中绝对不能这么写，否则编译器会误以为这是一个参数为abc的函数。必须采用如下一种：</p>
<pre><code><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>激进模式会不会限制语言的表达力呢？我认为不会，因为我们可以用对象或数组作为参数，就像上面的例子那样，JSON本身已经十分方便了。</p>
<p>兼容模式中，我们还可以使用<code>'</code>来达到类似splat的效果：</p>
<pre><code><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>这两个是不同的：</p>
<pre><code><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>凡是函数都有一个返回值，值即为函数块的值，所以我们无需使用<code>return</code>。</p>
<p>不像CoffeeScript，我们没有胖箭头<code>=&gt;</code>。我认为JavaScript使<code>this</code>的含义可自定义是一种错误的设计，它应该始终指向当前对象。我们的函数和CoffeeScript的函数的对应关系如下：</p>
<ul>
    <li>类的方法和构造器（包括嵌套的类的方法和构造器）：CoffeeScript瘦箭头</li>
    <li>类的方法和构造器内部（不包括嵌套的类的方法和构造器，但包括嵌套的类的方法和构造器内部）：CoffeeScript胖箭头</li>
    <li>其余地方：CoffeeScript瘦箭头</li>
</ul>
<h2>赋值与声明</h2>
<p>用<code>:</code>、<code>as</code>。例如：</p>
<pre><code><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b = 4 ? alert "impossible!" # var b; if ((b = 3) === 4) {alert("impossible");}
]]></code></pre>
<p>注意，<code>:</code>不构成表达式，但<code>as</code>构成表达式。例如：</p>
<pre><code><![CDATA[
    abc: <> a: 1
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>void</code>而不是<code>1</code>。但</p>
<pre><code><![CDATA[
    abc: <> 1 as a
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>1</code>。</p>
<p>变量不用声明也不能声明，这是因为我们为变量赋值的机制和CoffeeScript相同，如果前面还未出现过则会编译成声明并赋值，如果已出现过则会编译成单纯赋值。</p>
<p><code>:</code>也支持数组解构赋值（不包括嵌套），例如：</p>
<pre><code><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>冒号的作用就是让左边的拥有右边的值。无论是对象中的冒号还是赋值中的冒号，含义相似。</p>
<p><code>:</code>支持对多标识符同时赋值，例如：</p>
<pre><code><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<p>还可以对包含子语句的语句用<code>as</code>，例如：</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        as f1

        x ->
            ddd(x)
            eee(x)
            fff(x)
        as f2
    ]
]]></code></pre>
<p>如上例显示，这种<code>as</code>和下一语句之间最好要有空行，不然不容易看清这个<code>as</code>是属于谁的。但我们也提供了你不空行时的好办法，就是加个<code>above</code>。</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        above as f1
        x ->
            ddd(x)
            eee(x)
            fff(x)
        above as f2
    ]
]]></code></pre>
<p><code>above</code>对机器来说没有任何意义，不加也是合法的，但对人来说有意义。不过我的看法是，空行更直观些，打起来也更方便。</p>
<p>要注意，上面两个例子中<code>as</code>和上面的函数并不是两个并列的语句，而是一个语句。语句不能以<code>as</code>或<code>above as</code>开头。</p>
<h2>模块</h2>
<p>一个文件即是一个模块。和模块有关的语法有<code>import</code>、<code>export</code>、<code>'export</code>。</p>
<pre><code><![CDATA[
    main: import "lib"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" as main
]]></code></pre>
<p>都是指导入ES6中的“默认导出”，等同于JS的</p>
<pre><code><![CDATA[
    import main from "lib";
]]></code></pre>
<p>还可以导入所有的“命名导出”：</p>
<pre><code><![CDATA[
    lib: import "lib" all
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" all as lib
]]></code></pre>
<p>相当于JS的</p>
<pre><code><![CDATA[
    import * as lib from "lib";
]]></code></pre>
<p>还可以导入指定的“命名导出”：</p>
<pre><code><![CDATA[
    {fun1, fun2 as f2}: import "lib"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    import "lib" as {fun1, fun2 as f2}
]]></code></pre>
<p>相当于JS的</p>
<pre><code><![CDATA[
    import {fun1, fun2 as f2} from "lib";
]]></code></pre>
<p>不支持在一个语句里同时导入“默认导出”和“命名导出”，有此需求请分两个语句。我认为一个模块既有“默认导出”又有“命名导出”并不好。</p>
<p>注意，其实上面的一些例子利用了<code>all</code>在用大括号的情况下可省略的特性。如果要写全，应该是：</p>
<pre><code><![CDATA[
    {fun1, fun2 as f2}: import "lib" all
    import "lib" all as {fun1, fun2 as f2}
]]></code></pre>
<p><code>import</code>后面只能跟内联普通字符串，并且字符串里不可以有插值（但可以有转义符）。这些都是正确的语法：</p>
<pre><code><![CDATA[
    import "./abc" as abc
    abc: import "./abc"
    import "abc"
    import("\u0041")
]]></code></pre>
<p>这些是错误的语法：</p>
<pre><code><![CDATA[
    import "./a" + "bc"
    import("./a" + "bc")
    import "./\(filename)"
    import v"abc"
]]></code></pre>
<p><code>import</code>的赋值不是普通的赋值，它是“绑定”的，和ES6一样。所以，语法上有限制，它只能是赋给变量，不能赋给对象属性，也不能在冒号左边出现<code>ifvoid</code>、<code>ifnull</code>。</p>
<p>导出时，我们可以使用4种语法：<code>export</code>、<code>'export</code>、<code>export as</code>、<code>export ... as</code>。这些都是正确的语法：</p>
<pre><code><![CDATA[
    multiply'export: <> @0 * @1
    mp: (<> @0 * @1) export as multiply
    mp: <>
        @0 * @1
    above export as multiply
    mp: <> @0 * @1
    above export as multiply
    <> @0 * @1
    above export as multiply
    mp: (<> @0 * @1) as multiply'export
    abc export as def
    export abc as def
    export abc
    export <> @0 * @1
]]></code></pre>
<p>和赋值一样，这里的<code>above</code>也是可略的。</p>
<p>这些是错误的语法：</p>
<pre><code><![CDATA[
    abc export def
    export: abc
    export multiply: <> @0 * @1
    obj.multiply'export: <> @0 * @1
]]></code></pre>
<p>当语句以<code>export</code>开头，且<code>export</code>后除了一个表达式再无其他时，表示ES6中的“默认导出”。文件中这种语句只能出现一次，而且若出现则不能含有其他形式的导出，否则必须产生编译错误。这是因为如前面提到的，一个模块既有“默认导出”又有“命名导出”不好，虽然出于兼容考虑，Lemo支持导入其他这种架构的模块，但自己的模块就不要使用这种架构了。</p>
<p>导入和导出必须出现在顶层，因为这是基于ES6的。我们是静态导入，无法动态导入，这比Node要严格。当然，我知道有些场合可能需要动态导入，那你完全可以抛弃Lemo的原生模块语法，而用<code>Node</code>的<code>require</code>。</p>
<h2>字符串、正则表达式</h2>
<p>字符串受CoffeeScript启发，不同之处在于不用单引号、不用3个连续引号、不支持字符串的多行自动连接。</p>
<p>内联字符串：</p>
<pre><code><![CDATA[
    str: "Welcome to Lemo!"
]]></code></pre>
<p>格式字符串：</p>
<pre><code><![CDATA[
    htmlStr: "
        <p>
            Welcome to "Lemo"!
        </p>
    "
]]></code></pre>
<p>上例的字符串其实就相当于CoffeeScript的：</p>
<pre><code><![CDATA[
    htmlStr = """
        <p>
            Welcome to "Lemo"!
        </p>
    """
]]></code></pre>
<p>你一定觉得奇怪，为什么我们只需用一个引号就能包住一大段文字（文字本身也有引号），秘密在于我们要求在格式字符串内部，任何行的缩进都必须大于引号的缩进，且起始引号和结束引号的缩进必须相同，所以内部有再多引号也没关系，不影响编译器判断。</p>
<p>格式字符串的起始引号后面必须紧接一换行（这两个换行不算作字符），且结束引号所在的行中，该引号前面必须全是空白。格式字符串的缩进是从字符串内部除空行外缩进最小的一行的缩进的相同值开始算作字符。</p>
<p>格式字符串内部不可以全是空白（但用转义符表示的空白除外）。例如这些都是非法的：</p>
<pre><code><![CDATA[
    str: "
    "

    str: "

    "
]]></code></pre>
<p>这个虽然表示一个空格，但是是允许的：</p>
<pre><code><![CDATA[
    str: "
        \x20
    "
]]></code></pre>
<p>编译器是怎样判断某个引号是内联的还是格式的？看起始引号后面紧接的字符，如果是换行，则为格式，如果是其他字符，则为内联。</p>
<p>我们不用单引号，因为我觉得你要想用单引号，当字符串很长时，你可以用格式<code>"</code>；当字符串很短时，像<code>'"'</code>，这其实只增加了微小的可读性，我宁愿写成<code>"\""</code>。无论哪一种用单引号都没有明显优势，所以，还是别占用宝贵的符号资源为好。而且双引号是和JSON一致的。</p>
<p>也支持字符串插值，就像CoffeeScript，不过我们使用<code>\(...)</code>。</p>
<pre><code><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>一个插值不能占据多行。暂不支持嵌套的插值，相信很少有这种需求。</p>
<p>上面介绍的都是普通字符串。除了普通字符串外，还有特殊字符串，还有字符串转换值表示法。什么是字符串转换值表示法呢？正则表达式就是典型的例子。</p>
<p>正则表达式我们用<code>r"..."</code>来表示。例如：</p>
<pre><code><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>内联正则表达式废除了<code>\</code>的大部分功能，除了3个：<code>\"</code>、<code>\#</code>、用于行尾连接的<code>\</code>。注意，JS的正则表达式里的<code>"</code>和<code>#</code>可以直接表示，但在这儿必须用<code>\"</code>和<code>\#</code>，因为这两个字符有特殊含义。</p>
<p>正则表达式可以有插值，插入的是字符串：</p>
<pre><code><![CDATA[
    first: "hello"
    second: "world"
    r"#(first)-#(second)"
]]></code></pre>
<p>和CoffeeScript相同，正则表达式的插值如果是普通字符串的话，如果想用字面量表示<code>\</code>字符，会比较繁琐，所以建议仅把插值用于动态插入非符号字符。</p>
<p>还可以表示带有标志的正则表达式：</p>
<pre><code><![CDATA[
    r"\d{3}-\d{3}-\d{4}"gim
]]></code></pre>
<p>格式正则表达式的例子：</p>
<pre><code><![CDATA[
    str.search(r"
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    ")
]]></code></pre>
<p>格式正则表达式的不同点是：空格和换行无意义，支持注释，表示双引号字符更简单。</p>
<p>原义字符串是受C#启发。原义字符串用<code>v"..."</code>来表示，例如：</p>
<pre><code><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>原义字符串完全废除了<code>\</code>的功能，所以行末不能用<code>\</code>来连接，在内联原义字符串中也无法表示双引号字符。</p>
<p>所以总结一下，凡是字符串起始符号<code>"</code>左边紧接着字母的，可以是表示字符串，也可以表示字符串经转换后的值。</p>
<p>正则表达式引号中间的内容本质上是字符串，这和JS和CoffeeScript都不同。就算是格式正则表达式中的注释，本质上是属于字符串的，只是转换时去掉了而已。注意，转换是编译时而不是运行时，所以不影响效率。</p>
<p>还有一点和CoffeeScript不同，就是CoffeeScript中：</p>
<pre><code><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
    never mind how long precisely -- having little
    or no money in my purse, and nothing particular
    to interest me on shore, I thought I would sail
    about a little and see the watery part of the
    world..."
]]></code></pre>
<p>这会编译成多行自动连接，连接符是一个空格。但是我们不支持，一个原因是这和我们的格式不兼容，另一个原因是我觉得这只适合西方语言。如果是中文，那加上空格可就错了。所以这个功能不好，应该老老实实用<code>\</code>来连接，是英文的话，前面加个空格。</p>
<table>
    <tr>
        <th></th>
        <th>内联"</th>
        <th>格式"</th>
        <th>内联v"</th>
        <th>格式v"</th>
        <th>内联r"</th>
        <th>格式r"</th>
        <th>内联js"</th>
        <th>格式js"</th>
    </tr>
    <tr>
        <td>转义符\</td>
        <td>有</td>
        <td>有</td>
        <td>无</td>
        <td>无</td>
        <td>仅\"、\#、连接</td>
        <td>仅\#、连接</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>插值</td>
        <td>\(...)</td>
        <td>\(...)</td>
        <td>无</td>
        <td>无</td>
        <td>#(...)</td>
        <td>#(...)</td>
        <td>无</td>
        <td>无</td>
    </tr>
    <tr>
        <td>\"</td>
        <td>有</td>
        <td>有但不需</td>
        <td>无</td>
        <td>不需且无</td>
        <td>有</td>
        <td>不需且无</td>
        <td>无</td>
        <td>不需且无</td>
    </tr>
</table>
<h2>数组</h2>
<p>方括号的作用就是表示数组或类似数组的东西（用于解构赋值等），没有其他用途。</p>
<p>点号的作用就是表示对象的字段。由于数组也是对象，所以JS中<code>arr[3]</code>我们改为<code>arr.3</code>，更一致。其实数组就是属性名为索引值的对象，刚知道时可能会惊讶，但确实是这样，可以用<code>Object.keys(arr)</code>验证这一论断。JS这点和别的语言不同，但不是糟粕，只要形式上变得一致就可以了。</p>
<p>当然，在和带小数点的数字同时出现时，会感觉别扭，这时建议加上括号。比较一下：</p>
<pre><code><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p>数组的表示法和CoffeeScript完全相同。</p>
<h2>对象</h2>
<p>对象的表示法和CoffeeScript基本相同，除了它必须加上大括号，不能省略。</p>
<h2>逻辑运算</h2>
<ul style="font-family: monospace;">
    <li>=</li>
    <li>/= (not =, not=, !=)</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>等号的作用就是判断相等，不用再考虑烦人的<code>=</code>、<code>==</code>、<code>===</code>之间的区别。</p>
<p><code>/=</code>表示不相等，也可写作<code>not =</code>，中间的空白可有可无。考虑程序员们的习惯，目前也支持使用<code>!=</code>，但是建议尽量少用，因为以后有可能会删掉。我觉得单独的感叹号用于表示<code>not</code>是不合适的，<code>not</code>已经够简洁了。如果单独的感叹号在未来有语义（目前还被尘封），那么<code>!=</code>就有可能会产生歧义，所以那时就有可能删除。</p>
<p>和CoffeeScript一样，我们也支持这种链式比较：</p>
<pre><code><![CDATA[
    if 200 <= statusCode < 300
        console.log "success"
]]></code></pre>
<p>但是我们的限制比CoffeeScript多，只有同一个方向的才可以链式比较。像这种就不支持：</p>
<pre><code><![CDATA[
    if a < b > c
        console.log "success"
]]></code></pre>
<p>Lemo和其他语言在逻辑运算方面最大的区别就是<code>not</code>的优先级。<code>not</code>的优先级被降低，仅高于<code>and</code>和<code>or</code>。这意味着我们可以少加很多括号。你肯定抱怨过在JS中不得不这样写：</p>
<pre><code><![CDATA[
    if !(abc instanceof Abc) doTask();
]]></code></pre>
<p>但现在我们可以：</p>
<pre><code><![CDATA[
    if not abc instanceof Abc
        doTask()
]]></code></pre>
<p>当然这个例子只是打个比方，事实上我们没有<code>instanceof</code>关键字，我们是用<code>is</code>关键字，<code>not ... is</code>可能显得不太好看，所以就不举出来了。那有没有好看的例子呢？也有，像这种也不用加上括号：</p>
<pre><code><![CDATA[
    if not 200 <= statusCode < 300
        console.log "failure"
]]></code></pre>
<h2>条件</h2>
<p>用<code>if</code>、<code>?</code>、<code>then</code>、<code>else</code>、<code>|</code>。例如：</p>
<pre><code><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
也可以并成一行：
<pre><code><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>甚至</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code>和<code>then</code>等价，<code>|</code>和<code>else</code>等价，这条规则不仅限于<code>if</code>语句，在所有地方通用。下文提到的它们任何一个的规则也适用于它的等价方。</p>
<p>条件前置时，<code>if</code>可写可不写，而<code>then</code>则当有<code>then</code>块时可写可不写。<code>if</code>省略时要注意避免出现优先级的问题，例如：</p>
<pre><code><![CDATA[
    a if b > 100 then 100 else b
]]></code></pre>
<p>这里的<code>if</code>省略的话意思就完全不一样了，除非加个括号。</p>
<p>当<code>then</code>后紧接的是表示命令语句的关键词时，<code>then</code>也可省略（这也适用于模式匹配）。例如：</p>
<pre><code><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>但是要注意，条件前置时无论怎样省略，<code>if</code>和<code>then</code>必须至少出现一个。</p>
<p>如果<code>else</code>块省略，那么则当<code>else</code>时整个<code>if</code>表达式的值为<code>void</code>。</p>
<p>条件还可以后置，这时就只能用<code>if</code>，例如：</p>
<pre><code><![CDATA[
    alert("a is true!") if a # if (a) {alert("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p>一条语句中只可以含有一个后置的<code>if</code>。</p>
<p>还有一点和CoffeeScript不同，就是当碰到分号时：</p>
<pre><code><![CDATA[
    if x > 100 then aaa(); bbb()
]]></code></pre>
<p>CoffeeScript是把<code>aaa(); bbb()</code>全作为子语句，这看上去似乎是硬插入一条规则，很不统一，而且我们已有了专门的符号，可以写成：</p>
<pre><code><![CDATA[
    if x > 100 << aaa(); bbb() >>
]]></code></pre>
<p>所以这条规则在我们这里作废。Lemo里，分号的左右两边能在不引发语法错误的前提下穿越一切障碍物。</p>
<h2>模式匹配</h2>
<p><code>match</code>可以看成是一个增强版<code>switch</code>，它称为模式匹配。例如：</p>
<pre><code><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>上面只是最普通的模式匹配，<code>day</code>是输入，1、2、3……称作模式。它不但比JavaScript的switch强大，甚至比CoffeeScript的switch还强大，看看这个：</p>
<pre><code><![CDATA[
chessBoard: (pos) -> match [pos.x, pos.y]
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>这个称为数组模式。它不是简单地比较两个数组是否相等（那样会始终不相等，因为不是同一个引用），而是检查数组（直接，非嵌套）中每个元素是否相等。当模式以<code>[</code>开头时，适用数组模式。注意一定要直接写出<code>[</code>，绝不能用变量替代，像这样是没用的：</p>
<pre><code><![CDATA[
    a: [0, 0]
    b: [0, 1]
    c: [4, 5]
    chessBoard: (pos) -> match [pos.x, pos.y]
        a ? "king"
        b ? "pawn"
        c ? "queen"
        |   "empty"
    piece: chessBoard {x: 4, y: 5} # will be "empty"
]]></code></pre>
<p>模式匹配中的“比较”默认是用<code>=</code>，还可以用其他比较运算符，例如：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100 ? "unsupported"
        200 ? "informational"
        300 ? "success"
        400 ? "redirect"
        500 ? "client error"
        600 ? "server error"
        |     "unsupported"
]]></code></pre>
<p><code>else</code>可以跟前面的并在一起，此时用<code>or else</code>，但该项不能有<code>then</code>。在模式中，<code>or</code>这个关键字若不作为运算符使用，可以简写为逗号<code>,</code>，所以上面的例子可以写成：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100, | "unsupported"
        200  ? "informational"
        300  ? "success"
        400  ? "redirect"
        500  ? "client error"
        600  ? "server error"
]]></code></pre>
<p>用<code>or else</code>的时候<code>or</code>还可以省略，所以还可以写成：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100 | "unsupported"
        200 ? "informational"
        300 ? "success"
        400 ? "redirect"
        500 ? "client error"
        600 ? "server error"
]]></code></pre>
<p>不但可以用比较运算符，还可以自定义比较函数，例如：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match <> text.includes(@)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>当<code>match</code>后紧接的是函数时，则被识别成自定义比较函数。要直接写出<code>-&gt;</code>或<code>&lt;&gt;</code>，绝不能用变量替代，这一点和数组模式相似。</p>
<p>还有or模式和and模式。or模式我们会经常用到，例如：</p>
<pre><code><![CDATA[
    day: "Tue"
    action: match day
        "Sat", "Sun" ? "have a rest"
        |              "work"
]]></code></pre>
<p>and模式则不常用，但也有例子：</p>
<pre><code><![CDATA[
    array: ["a", "c", "b", "d"]
    message: match <> array.includes(@)
        "a" and "b" and "c" ? "The array includes all of the first 3 letters."
        "a"                 ? "The array includes a."
        "b"                 ? "The array includes b."
        "c"                 ? "The array includes c."
        |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>由此可知，or和and作为运算符在模式中使用是有限制的，它作为运算符时必须出现在括号内，否则会被认为是模式。所以真的有这个需求的话，要用个括号包起来。不过这两个运算符出现在模式中好像也没有什么用。</p>
<p>作为模式使用时要么全是<code>or</code>，要么全是<code>and</code>，两个不能在一个模式中一起出现，否则编译器会无法判断。括号内的无此限制。</p>
<p>注意<code>or else</code>是一种特殊的写法，并不属于or模式，所以<code>or else</code>可以和<code>and</code>在一个模式中一起出现。</p>
<p>和<code>if</code>一样，可以有<code>then</code>块，这时就不用写<code>then</code>了：</p>
<pre><code><![CDATA[
    day: 3
    match day
        6
            go bingo
            go dancing
        7
            go church
        |
            go work
]]></code></pre>
<p>可以看出，即便是模拟传统的<code>switch</code>，依然比<code>switch</code>简洁。</p>
<h2>循环</h2>
<p>循环其实并不符合函数式编程的理念，我们没有循环。但我的mate库提供了全局函数repeat来模拟循环。为方便起见，本文中的“循环”一般指repeat。例子：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>迭代器返回<code>break</code>则表示跳出循环，类似于JS的<code>break</code>，不过本质上不同，这里的<code>break</code>是表达式，只能使余下的循环不做，并不能使函数内剩下的部分不执行。跳出循环时repeat函数返回<code>break</code>。例子：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        if i < 5
            console.log "This is \(i) time"
        else
            break
    ]
]]></code></pre>
<p>不设次数则表示永远，相当于JS的<code>while (true)</code>：</p>
<pre><code><![CDATA[
    repeat --
        if abc()
            break
        else
            doSomething()
]]></code></pre>
<p>Mate的地址：https://www.npmjs.com/package/mate</p>
<h2>类</h2>
<p>和类有关的关键字有<code>class</code>、<code>super</code>、<code>new</code>、<code>nonew</code>、<code>me</code>、<code>Me</code>。例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me.name: @0

        move: meters ->
            alert me.name + " moved \(meters)m."

    Snake: class from Animal
        move: <>
            alert "Slithering..."
            super 5

    Horse: class from Animal
        move: <>
            alert "Galloping..."
            super 45

    sam: Snake "Sammy the Python"
    tom: Horse "Tommy the Palomino"

    sam.move()
    tom.move()
]]></code></pre>
<p>我们使用比传统更纯粹的形式：让赋值功能从class剥离出来，使用表达式而非语句。</p>
<p>类的声明方式比较像CoffeeScript。但我们的更严格。我们多了getter and setter功能，以及<code>constructor:</code>简写成<code>new:</code>。在Lemo中，类的所有声明的子项都必须是以冒号的形式。</p>
<p>JS的<code>this</code>我们用<code>me</code>代替。我们还有一个关键字<code>Me</code>，M大写，表示<code>me</code>所在的类。当静态调用时<code>Me</code>和<code>me</code>相同，但建议使用<code>Me</code>，因为大写比较像类。</p>
<p>getter和setter的例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p><code>'get</code>和<code>'set</code>一看就明白。这里的亮点是<code>me._name</code>，它编译成的JS不是像你猜测的那样是<code>this._name</code>，而是<code>this[_name]</code>，其中<code>_name</code>是Symbol。编译器一碰到<code>me.</code>，并且后面是以<code>_</code>开头的话，即这样编译。</p>
<p>这被称作“防冲突字段”，可以把它近似看成是私有字段。防冲突字段的好处不是外部无法访问，外部虽然无法通过对象的属性直接访问，但可以间接访问，最大的好处是继承类可以放心地使用同名的防冲突字段，而不用担心会覆盖，这在类关系很复杂的大型项目中尤其重要。因为这些字段不属于API，通常别的开发者是不会告诉你是怎样用的，如果你继承别人写的类，有可能你的私有字段正好重名，类的行为就被破坏了。</p>
<p>以<code>_</code>开头的字段名还可以出现在字段的声明中，例如：</p>
<pre><code><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>字段的声明中只要是以<code>_</code>开头的，便自动成为防冲突字段。</p>
<p>对于对象和类而言，属性、成员、字段是同义词。方法是指为函数的字段。</p>
<p>创建实例时无需使用new，因为其实JS的new是多余的，如果一个函数只能被当作类来使用，肯定会加new。所以在Lemo中，只要这被识别为一个类，那么当被作为函数调用时，编译出来的就会自动加上new。反之，如果不是类，编译出来的就不会加上new。具体的识别方法由版本行指定。当然，罕见的情况下，某个库的函数名可能会不符合约定，造成被识别为类，这时可以用<code>nonew</code>关键字，语法上和<code>new</code>一样。</p>
<p><code>Number</code>、<code>String</code>、<code>Boolean</code>始终被识别为不是类，无论编译选项如何。</p>
<p>CoffeeScript对于静态字段是使用<code>@property: value</code>，我们使用的是<code>static</code>，即<code>static property: value</code>。</p>
<p>防冲突字段也适用于静态字段，区别是使用的不是<code>me.</code>而是<code>Me.</code>。</p>
<p>有的时候我们想写静态构造函数，也可以，<code>static</code>后面不要跟任何名称即可，例如：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result[0]
            Me.part2: result[1]
]]></code></pre>
<p>静态构造函数内的<code>me.</code>和<code>Me.</code>都指向当前闭包所在的类，即这个类本身，而不是当前对象的类。</p>
<p>不要在类的方法或构造器内部为另一个对象的原型方法赋值。例如这样不合理（虽然不会出错）：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>这是因为在该原型方法内使用<code>me</code>的话表示不了你想要表示的东西。正确的方法是把它写在类的外面。至于嵌套类，是可以的，因为编译器能识别<code>class</code>关键字，从而做出对于<code>me</code>的正确解释。不过嵌套类好像用处也不大，建议类与类的关系还是扁平为好。</p>
<p>只要类有实例化需求，就要避免取非大写开头的名称，否则会影响编译器判断。如果类的所有需求都是静态，那么就任意了。</p>
<h2>上下文</h2>
<p>JavaScript表示上下文的只有this和arguments，我们有5个，分别是：</p>
<ul>
    <li>当前对象：<code>me</code></li>
    <li>当前对象的类：<code>Me</code></li>
    <li>闭包中的当前函数：<code>fun</code></li>
    <li>当前参数：<code>@</code></li>
    <li>赋值中冒号左边的标识符的旧值：<code>self</code></li>
</ul>
<p><code>@</code>后面的点号可以省略，除非点号后面跟<code>(</code>，或者<code>"</code>、<code>v"</code>、<code>r"</code>之类的字符串或字符串扩展。</p>
<h2>异常</h2>
<p>用<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>，具体实现和CoffeeScript几乎完全相同。例如：</p>
<pre><code><![CDATA[
    try
        allHellBreaksLoose()
        catsAndDogsLivingTogether()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<p>唯一的不同是：若<code>throw</code>后面啥都没有，不是语法错误，而是：若在catch块内则编译成<code>throw catchExceptionVar</code>，若不在catch块内则编译成<code>throw new Error()</code>。</p>
<h2>管道</h2>
<p>管道操作符是<code>|></code>。例子：</p>
<pre><code><![CDATA[
    u: require("underscore")
    [3, 4, 5] |> u.map(x -> x * 2) |> u.max
]]></code></pre>
<p>管道使我们使用underscore函数库可以一种人类习惯的顺序来书写，我们再也不用这样写了：</p>
<pre><code><![CDATA[
    u: require("underscore")
    u.max(u.map([3, 4, 5], x -> x * 2))
]]></code></pre>
<p>还有一种运算符<code>::</code>，称之为“胖点”，专门应用于含有管道运算符的表达式，如果你想让管道和点号混合，胖点能提供更强的可读性。例如：</p>
<pre><code><![CDATA[
    [3, 4, 5] |> u.map(x -> x * 2) :: map(x -> x + 1) |> u.max
]]></code></pre>
<p>相当于：</p>
<pre><code><![CDATA[
    (([3, 4, 5] |> u.map(x -> x * 2)).map(x -> x + 1)) |> u.max
]]></code></pre>
<p>所以胖点基本就是点号，只不过它的优先级略低，和管道运算符相同。而且看起来比较“胖”，和管道运算符比较接近，显得比较舒服。</p>
<h2>异步</h2>
<p><code>'wait</code>类似C#的await，使异步看上去像同步一样（然而不改变其异步的本质），所以它超越了promise。考虑这样一个JS：</p>
<pre><code><![CDATA[
    abc().then(function(x){
        return x.def();
    })
    .then(function(x){
        return x.ghi();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>我们现在可以写成：</p>
<pre><code><![CDATA[
    console.log abc()'wait.def()'wait.ghi()'wait
]]></code></pre>
<p>一旦代码有<code>'wait</code>，那么代码所在的函数（直接所在，非嵌套）就被编译成异步函数。我们不用async关键字声明异步函数，这个关键字根本多余。</p>
<p><code>'wait</code>针对的要么是promise，要么是别的异步函数的返回值。异步函数的返回值是被编译成一种特殊的生成器对象，我们将其称为任务。注意，生成器对象不是生成器函数。</p>
<p>在异步函数内部，每执行到<code>'wait</code>，会进入等待，直到该promise或任务有了结果，才继续往下执行。</p>
<p>网上已有文章介绍如何用yield来实现异步，那我们为什么不直接用yield，要发明一个新的符号？因为：</p>
<ul>
    <li>yield的本来意思是“产出”，用来表示异步显得怪怪的。</li>
    <li>yield是前置的，但这里其实应该后置。试想，前面的例子翻译成yield会是什么样？<code>var result = yield (yield (yield abc()).def()).ghi();</code>多层括号，前面3个yield，多难看？而且从时间顺序来说也应该后置。其实C#的await也应该是后置，它也弄得不好。是什么时候wait？是promise函数或异步函数执行完后wait，而不是wait之后再执行。注意promise函数执行完不表示promise有了结果，promise函数本身的执行是同步的。</li>
</ul>
<p>异步和管道结合的例子：</p>
<pre><code><![CDATA[
    x: data |> lib.process1'wait |> lib.process2'wait
    y: data |> lib.remoteCombine(anotherData1)'wait |> lib.remoteCombine(anotherData2)'wait
    console.log(x, y)
]]></code></pre>
<p>调用异步函数也可以不加<code>'wait</code>，当调用方不需要等待promise或任务出结果的时候。</p>
<p>用<code>'wait</code>调用异步函数的例子：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
    task()'wait
    console.log "success"
]]></code></pre>
<p>不用<code>'wait</code>，也可以调用异步函数并达到相同的目的：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
        console.log "success"
    task()
]]></code></pre>
<p>注意，不用<code>'wait</code>调用异步函数的时候，异步函数执行到第一个<code>'wait</code>的位置之前返回调用方。下面的例子说明了先后顺序：</p>
<pre><code><![CDATA[
    task: <>
        console.log "stage 1"
        aaa()'wait
        console.log "stage 3"
        bbb()'wait
        console.log "stage 4"
    task()
    console.log "stage 2"
]]></code></pre>
<p>其实用<code>'wait</code>调用异步函数的时候也是异步函数执行到第一个<code>'wait</code>的位置之前返回调用方，只不过调用方也在等待，看起来就像没有返回一样。</p>
<p>异步和<code>do</code>结合的例子：</p>
<pre><code><![CDATA[
    largeTask: <>
        do'wait <>
            aaa()'wait
            bbb()'wait
        do'wait <>
            ccc()'wait
            ddd()'wait
        do'wait <>
            eee()'wait
            fff()'wait
]]></code></pre>
<h2>存在</h2>
<p>这几个关键字或操作符和“存在性”有关<code>'ok</code>、<code>ifvoid</code>、<code>ifnull</code>。</p>
<p><code>a'ok</code>，意思就是a既不是void，也不是null。</p>
<p><code>'ok</code>还可以和点号结合起来使用，<code>'ok.</code>等同于CoffeeScript的<code>?.</code>，例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.winner?.address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip: lottery.winner'ok.address'ok.zipcode
]]></code></pre>
<p><code>'ok</code>还可以和函数调用结合起来使用，和CoffeeScript的<code>?(...)</code>一样。例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner?().address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip: lottery.drawWinner'ok().address'ok.zipcode
]]></code></pre>
<p><code>ifnull</code>和<code>ifvoid</code>有两种形式，一种是后面跟冒号，一种是后面不跟冒号。例如：</p>
<pre><code><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a ifvoid: 8 # if (a === undefined) {a = 8;}
    b: a ifvoid 8 # b = a !== undefined ? a : 8;
]]></code></pre>
<h2>'</h2>
<p><code>'</code>的形式有两种，一种是一元<code>'</code>，一种是二元<code>'</code>。一元<code>'</code>即函数的单参数变体，兼容模式专用。其他的都是二元<code>'</code>。</p>
<p>编译器如何判断某个<code>'</code>是一元还是二元？看<code>'</code>后面紧跟的字符。如果是数字或字母，则是二元，否则（例如是符号、空格或根本没有字符）要么是一元，要么无法解析。</p>
<p>所以这两者是一样的：</p>
<pre><code><![CDATA[
    a'ok
    a 'ok
]]></code></pre>
<p>但这个不一样：</p>
<pre><code><![CDATA[
    a' ok
]]></code></pre>
<p>为了可读性，一元的<code>'</code>前面的那个字符不能是空白。像这个就是非法的，必须无法解析：</p>
<pre><code><![CDATA[
    a ' ok
]]></code></pre>
<p>有些情况下二元<code>'</code>的第一个算元可以省略，例如函数参数默认值中的变量名，但是它仍然属于二元。</p>
<h2>in</h2>
<p><code>in</code>的用法和CoffeeScript几乎完全相同，当然，如果要表示否定，可以用<code>not in</code>，不能用<code>!in</code>。</p>
<h2>is</h2>
<p><code>is</code>表示左边是右边的类型，类似于JavaScript的<code>instanceof</code>，但又有些区别，它还能判断原始类型，可以说结合了<code>instanceof</code>和<code>typeof</code>。当右边是<code>Number</code>、<code>Boolean</code>、<code>String</code>（必须严格表示为这3个之中的1个，不能是引用）时使用<code>typeof</code>。</p>
<pre><code><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>与<code>in</code>相似，<code>is</code>表示否定时也是可以用<code>not is</code>，不过也可以使用更顺眼的<code>isnt</code>，但切记，绝不能用<code>is not</code>。</p>
<h2>delete</h2>
<p><code>delete</code>和JavaScript中的稍有不同。它不再是一个表达式。这是因为在JavaScript strict mode中并没有值为false的情况，而是抛出异常。既然我们都是用strict mode，所以没必要弄成表达式。</p>
<h2>rem和mod</h2>
<p><code>rem</code>即是JavaScript的<code>%</code>。<code>mod</code>是另一种求余，正负号和除数相同，只要除数是正数，结果就不为负，所以这种求余适用范围可能更广一些。<code>a mod b</code>相当于JavaScript的<code>(a % b + b) % b</code>。</p>
<h2>+和-（正负号）</h2>
<p>一元的<code>+</code>、<code>-</code>（正负号）的用法和CoffeeScript相似但有微小区别，我们规定它只能是紧接着算元，如果有空格则被当作加号和减号。例如：</p>
<pre><code><![CDATA[
    # a is 5. `-2` can't be connected because it is a valid statement.
    # To connect, either add a space or move the `-` to the first line
    a: 5
    -2

    # a is 5-2=3
    a: 5
    - 2

    a: -1 # valid
    a: - 1 # invalid
]]></code></pre>
<h2>do</h2>
<p><code>do</code>关键字的用法和CoffeeScript完全相同。</p>
<h2>注释</h2>
<p>使用<code>#</code>和<code>###</code>，和CoffeeScript几乎完全一样，只是我们的<code>###</code>更严格一点，起始和结尾的<code>###</code>必须独占一行且缩进相同，里面内容的缩进不可以小于<code>###</code>的缩进。</p>
<h2>插入JavaScript</h2>
<p>使用<code>js"</code>。例如：</p>
<pre><code><![CDATA[
    hi = js"function() {
        return [document.title, 'Hello JavaScript'].join(': ');
    }"
]]></code></pre>
<p>它完全废除了<code>\</code>的功能，双引号也无法在其中用任何变通的办法表示（否则会有代价），不过妙在JS也支持单引号。如果必须用双引号，就用格式。</p>
<h2>&lt;&lt;和&gt;&gt;</h2>
<p>通常来说，把一行拆成几行会增加可读性。但有的时候恰恰相反，你会发觉把几行特别短小的代码合并成一行反而更好看，特别是当你有很多这样的“几行”的时候。例如：</p>
<pre><code><![CDATA[
    A: class << aaa: 1 >>
    B: class << bbb: 1 >>
    C: class << ccc: 1 >>
    D: class << ddd: 1 >>
    E: class << eee: 1 >>
]]></code></pre>
<p>和这个做对比：</p>
<pre><code><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>这时<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的威力就体现出来了。<code>&lt;&lt;</code>表示接下去的代码缩进一级，<code>&gt;&gt;</code>表示还原。</p>
<p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>必须在1行内结束。也就是说，只能把多行合并成1行，无法把多行合并成2行。</p>
<p>这两个符号和分号、逗号结合使用，可以达到最大程度的合并效果。分号合并行，但对象属性、数组元素、类属性需要用逗号合并。</p>
<p>在<code>&gt;&gt;</code>后可加分号或逗号，也可不加分号或逗号，例如：</p>
<pre><code><![CDATA[
    A: class << aaa: x -> << x + 1 >>, bbb: 3 >>
    if aaa << task1() >> else << task2() >>; commonTask()
]]></code></pre>
<p>这里的分号和逗号都是可略的。</p>
<h2>关键字</h2>
<ul style="font-family: monospace;">
    <li>above</li>
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>export</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>ifnull</li>
    <li>ifvoid</li>
    <li>import</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>rem</li>
    <li>self</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>命名限制</h2>
<p>变量名不可以是关键字。</p>
<p>类声明中的属性名如不用引号，则不可以是<code>new</code>、<code>static</code>。如用引号，则没有限制。</p>
<p>对象字面量的属性名没有限制。</p>
<p>当然，不用引号时，以上名称都需要满足JS标识符约束，即：每个字符都是字母、数字、<code>_</code>或<code>$</code>，且起始字符不是数字。</p>
<h2>符号</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>--</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>v"</li>
    <li>r"</li>
    <li>js"</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>!=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'ok</li>
    <li>'get</li>
    <li>'set</li>
    <li>'export</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
</ul>
<h2>运算符优先级</h2>
<p>运算符的运算结果是表达式，但算元不一定是表达式。不是所有运算符都有优先级。算元必须占满该行剩余部分（除非用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>）的运算符（即通常分多行写的）就没有优先级，例如<code>match</code>和<code>class</code>。下面表格中，优先级从低到高，a、b、c表示表达式算元，x、y、z表示不一定是表达式的算元。别的语言的参考都是优先级从高到低，但我觉得不妥，因为用函数式思维来看，应该从“大”（低）到“小”（高）。</p>
<table>
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="3">0 right-to-left</td>
        <td>Arrow Function</td>
        <td><code>x -&gt; y</code></td>
    </tr>
    <tr>
        <td>Diamond Function</td>
        <td><code>&lt;&gt; x</code></td>
    </tr>
    <tr>
        <td>Dash Function</td>
        <td><code>-- x</code></td>
    </tr>
    <tr>
        <td>1 right-to-left</td>
        <td>Conditional</td>
        <td><code>if a then b else c<br/>a ? b | c<br/>a if b</code></td>
    </tr>
    <tr>
        <td rowspan="3">2 right-to-left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>Space nonew</td>
        <td><code>nonew a b</code></td>
    </tr>
    <tr>
        <td>3 left-to-right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td>4 left-to-right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>5 right-to-left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td rowspan="6">6 left-to-right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td rowspan="4">7 left-to-right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="2">8 left-to-right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">9 left-to-right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td>10 right-to-left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="2">11 right-to-left</td>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td rowspan="2">12 left-to-right</td>
        <td>ifvoid</td>
        <td><code>a ifvoid b</code></td>
    </tr>
    <tr>
        <td>ifnull</td>
        <td><code>a ifnull b</code></td>
    </tr>
    <tr>
        <td rowspan="2">13 left-to-right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>export as</td>
        <td><code>a export as x</code></td>
    </tr>
    <tr>
        <td rowspan="2">14 left-to-right</td>
        <td>Pipe</td>
        <td><code>a |&gt; x</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
    <tr>
        <td rowspan="7">15 left-to-right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>Function Call</td>
        <td><code>a(b)<br/>a[b]<br/>a{x}</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>nonew</td>
        <td><code>nonew a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>import</td>
        <td><code>import "x"<br/>import("x")</code></td>
    </tr>
</table>
<h2>例子</h2>
<pre><code><![CDATA[
    # Assignment:
    number:   42
    opposite: true

    # Conditions:
    number: -42 if opposite

    # Functions:
    square: <> @ * @

    # Arrays:
    list: [1, 2, 3, 4, 5]

    # Objects:
    math: {
        root:   Math.sqrt
        square: square
        cube:   <> @ * square @
    }

    # Existence:
    alert "I knew it!" if elvis exists

    # Array comprehensions:
    cubes: list.map <> math.cube @
]]></code></pre>
<h2>常见问题</h2>
<p>问：为啥没有正则表达式符号？</p>
<p>答：正则表达式完全可以用<code>r"</code>来表示。</p>
<p>问：为啥没有位操作符？</p>
<p>答：首先，Lemo作为高级语言，没必要支持。其次，JavaScript的位操作是专门针对32位数字的，这本身就不合理。</p>
<p>问：为啥没有生成器？</p>
<p>答：生成器是适合特定用途的，似乎普适性还不够。至于缩短代码长度？加一个类库也可以达到这个目的，干嘛非得改动语言层面呢？至于在异步操作中的用途，Lemo也已经有了更好的替代方法。</p>
<p>问：为啥格式字符串的缩进必须大于引号处的缩进？等于也不行吗？</p>
<p>答：如果允许等于或小于，就有可能造成编译器误判，当字符串中某行行首正好是引号的时候。</p>
<p>问：为啥函数除了箭头符号以外还要弄个菱形符号？</p>
<p>答：我的目标是消除CoffeeScript中参数两边的括号。但是如果没有括号的话会产生歧义。所以我就想出了这个办法，如果不加括号，那就必须为1个参数。那零个参数怎么办？就再造一个符号呗。至于多个参数，就必须加括号，不过多参数并不在我的理想化（即激进模式）的构想当中，所以这也可以接受。再有一个原因，就是CoffeeScript用箭头表示零参数的话看上去既别扭又误导，箭头嘛，感觉应该左右都有东西才对。</p>
<p>问：既然如此，那为啥激进模式不废除箭头符号？反正有<code>@</code>可以用。</p>
<p>答：激进模式中，大多数情况下确实没必要给参数取名，但当你有多层函数，内层调用外层参数的时候，取名就有必要了。</p>
<p>问：为啥没有保留字？</p>
<p>答：很多语言都有很多保留字，但我觉得你设计语言的时候预先定义好未来的功能，那未来有可能是你没料到的。我们在版本行使用版本号，也达到了“安全”的目的，因为可以保证只要你不修改版本号，就不会出现兼容性问题。</p>
<p>问：不支持<code>var</code>是受CoffeeScript启发，但为啥不支持ES6的<code>let</code>和<code>const</code>？</p>
<p>答：我的理念是，一名程序员也许不熟悉正在开发的文件之外的其他文件，但是一般都会熟悉这个文件当中的其他区域。<code>let</code>提供块级的保护，但是只要你熟悉的不是只是这个块，你完全可以使用一个不同的变量名。块级保护太小了，函数级保护已经足够坚固。否则的话语言本身的复杂度也会增加。<code>let</code>和CoffeeScript风格之间也有矛盾。而且我们是编译成<code>var</code>，曾经我想把所有变量编译成<code>let</code>，但是考虑这样的代码：</p>
<pre><code><![CDATA[
    if x > 0
        a: 1
        b: 2
        c: 3
    else
        a: 4
        b: 5
        c: 6
    console.log(a + b + c)
]]></code></pre>
<p>如果是编译成<code>let</code>，那么这段代码是有错的，必须要在顶部给<code>a</code>、<code>b</code>、<code>c</code>赋值才行。所以我觉得还是编译成<code>var</code>好。</p>
<p>至于<code>const</code>，我觉得理念有问题，<code>const</code>只是针对常量而已，而我们让某个东西不可变，不是防自己改，是防别人改。通常是自己做了个库，别人使用时，在运行时可能会乱改内部逻辑。变量仅自己可见，别人改不了，又何必成为常量？真正要保护的其实是对象的属性或方法，这个<code>const</code>却无法做到。可以通过<code>Object.defineProperty</code>来做到。但要动就得动包括原生对象在内的所有的对象，让方法都变得坚固（即变成类似静态语言的样子），这工作量太大了，可行性也值得怀疑，所以目前暂不做。</p>
<p>问：为何不支持对象解构赋值和复杂数组的解构赋值？</p>
<p>答：对象解构赋值过于复杂。它符合了人类一部分直觉，但违反了人类另一部分直觉，导致一开始根本就看不懂。复杂数组的解构赋值是中等复杂，以后也许会支持。至于对象解构赋值，以后即使支持，语法也要改得更自然。</p>
<p>问：为什么arguments用<code>@</code>表示？</p>
<p>答：首先，<code>@</code>形状也像个a。其次，<code>@</code>是符号中看上去最不像符号的，我们经常会使用孤立的<code>@</code>作为一个表达式，这时如果用其他符号，会显得不像个表达式，就不舒服了。</p>
<p>问：为什么以多参数调用函数一定要加括号？CoffeeScript不是可以不加吗？</p>
<p>答：多参数要用到逗号，不加括号的话，逗号到底分隔什么，不容易看清楚，大多数时候违反人类直觉。而且，现在默认是兼容模式，但因为我觉得激进模式更完美，如果多参数可以不加括号，就显得更加鼓励人们采用兼容模式了。</p>
<p>问：<code>@</code>很好用，如果catch的上下文也能用一个符号表示就好了。</p>
<p>答：本来我考虑再用个新的符号来指代子语句内的上下文，不仅限于catch，但想想，不宜。用<code>@</code>时你很容易看清某个<code>@</code>所对应的是哪个函数，因为函数符号很好辨认。但子语句仅有的特征是缩进，而缩进我们是用得非常多的，很容易这个新符号的意思会变来变去，导致你搞混。如果这个新符号仅限于catch，又适用面太小。</p>
<p>问：<code>as</code>为何不能用逗号同时赋值？</p>
<p>答：若支持，像这个表达式<code>[aaa as a, bbb]</code>就容易产生歧义。</p>
<p>问：保留旧版本的编译器，那岂不越来越庞大？好恐怖！</p>
<p>答：其实也没那么恐怖，我们在做Lemo的时候会采取一些手段，使增量不那么大。</p>
<p>问：真的所有旧版本的编译器都包括吗？</p>
<p>答：我们尽量包括。但如果我们发现某个旧版本有安全漏洞，那么我们则会删掉。若不存在与代码相同版本的编译器，编译的时候会出现警告，同时会自动用新版本的编译器编译。</p>
<p>问：CoffeeScript多行链式（chaining）方法调用不用加括号，这里为啥要加括号？</p>
<p>答：CoffeeScript其实是硬生生加了条规则，这会破坏语法的统一，而且虽然在一部分需求中更简洁了，但当有另一部分需求的时候却更复杂了。所以我决定不用这套方法。</p>
<p>问：为啥一个模块既有“默认导出”又有“命名导出”不好？</p>
<p>答：你完全可以分两个模块，或者给“默认导出”取个非default的名字（事实上“默认导出”的确是“命名导出”的一部分，名字是default）。</p>
<p>问：为啥<code>-&gt;</code>函数没有定义<code>@</code>？</p>
<p>答：当你参数有名称时，再用<code>@</code>就显得多余。这时用<code>@</code>唯一的作用就是当函数的参数数量可变时。但是如果你的函数参数数量可变，更好的做法是不设任何形参。也有一种情况是希望后半部分参数数量可变，但是我不太喜欢这样做，我建议把这部分参数弄成一个数组。</p>
<p>问：JS中可以用<code>typeof a === "undefined"</code>检查变量是否已定义又不引发异常，这里为啥做不到？</p>
<p>答：这好像并没有什么用。Lemo的变量统统编译成在函数顶部声明，所以变量的定义与否不是动态的，所以检查这个不应该是程序运行时做的事情。</p>
<p>问：CoffeeScript也有<code>return</code>，Lemo居然没有？</p>
<p>答：<code>return</code>是一种跳跃式语句，函数式风格应该尽量避免这种语句，很多函数式语言，像微软的F#，是没有<code>return</code>的，F#有循环，但是也没有能跳出循环的<code>break</code>命令。就好比现在人们都认为C语言的<code>goto</code>命令是很邪恶的，就是因为<code>goto</code>是跳跃性的。当然<code>return</code>只是跳出而已，不能自由跳跃，远没有<code>goto</code>那么邪恶，但我想，至少在Lemo语言的初创阶段，还是彻底一些好。其实你很容易就可以达到相同的目的。比如你想这样写：</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number return
        x * 2
]]></code></pre>
<p>现在你可以这样写：</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number
            void
        else
            x * 2
]]></code></pre>
<p>如果你嫌行多，可以这样写，也是2行：</p>
<pre><code><![CDATA[
    x ->
        x isnt Number ? void |
            x * 2
]]></code></pre>
<p>这种方式的好处就是结构更清晰，只要不抛出异常，函数的出口永远只有一个，永远在底部。</p>
<p>问：为啥幂运算符<code>**</code>的优先级和CoffeeScript不一样？</p>
<p>答：虽然和CoffeeScript不一样，但是和大多数有这个运算符的语言一样，比如F#，比如未来的ES7草案。CoffeeScript应该是考虑到<code>-3 ** 2</code>如果书写成-3<sup>2</sup>应该是-9，但这看上去非常别扭，除非你加个空格，成为<code>- 3 ** 2</code>，或者干脆都不用空格，成为<code>-3**2</code>，但很少有人会这么写，前者还和多行连接有冲突。另一个原因是，CoffeeScript这样做弄得不大协调，就<code>**</code>显得那么特殊，其实<code>*</code>的优先级理应只比<code>**</code>低一级，只不过<code>(-a) * b</code>恒等于<code>-(a * b)</code>，所以可能他们觉得无所谓就不调整了而已。</p>
<p>问：<code>not</code>优先级被大幅降低，这合理吗？</p>
<p>答：这看上去更自然，更符合人类阅读方式。我承认，这个改变从来没有人做过，具有冒险性。为了看看有没有反例，支持<code>not</code>应该维持目前通用的优先级，我看了GitHub的Atom编辑器的源代码（它是用CoffeeScript编写的），还看了我自己的代码。我发现，几乎没有一处<code>not</code>在目前通用的优先级下更简单的，这给了我信心。因为我的想法是，算术运算符，像加法、乘法，对它们的算元使用<code>not</code>是非常不好的，也许有人会利用这种方式来取巧，但可读性非常差，所以好的代码中是不会出现<code>not a + not b</code>的，这种反例不应该使用。引申到<code>=</code>、<code>&lt;</code>、<code>&gt;</code>也是一样。</p>
</body>
</html>
