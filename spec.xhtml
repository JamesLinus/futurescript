<!DOCTYPE html>
<html xml:lang="zh-Hans" xmlns="http://www.w3.org/1999/xhtml" style="font-size: 13pt;">
<head>
    <title>Less and more - Lemo语言 0.1.0</title>
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/base.css" type="text/css" />
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/simplified-chinese-modern.css" type="text/css" />
    <style type="text/css"><![CDATA[
        table {
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
        p > code {
            background-color: rgb(224,224,224);
            padding-left: 0.2em;
            padding-right: 0.2em;
        }
        pre {
            border-left: 0.6em solid rgb(224,224,224);
            padding: 0.25em 1em;
        }
    ]]></style>
    <script src="http://zizisoft.com/doc-html.js" type="text/javascript" />
</head>
<body>
<h1>Less and more - Lemo语言 0.1.0</h1>
<p>詹臻臻 zhanzhenzhen@hotmail.com</p>
<h2>引言</h2>
<p>JavaScript实在是一门很怪的语言。它早年加入了很多无用的功能，不幸的是，出于兼容性考虑，这些功能永远都不能被删掉。另一方面，JavaScript却缺少很多真正有用的功能。当然，刚刚发布的 ECMAScript 6th 补足了大部分缺少的东西，但代价是显得臃肿不堪。如果有一门新的语言，它只继承JavaScript最精华的部分呢？JavaScript最精华的部分是什么？我觉得JSON肯定包括在内，其他的就不多了。下面介绍Lemo语言，它编写的代码可以被JS调用。但反过来则不尽相同，如果使用了激进编译选项，那么大部分传统JS无法被Lemo代码所调用。但如果使用兼容选项，那么可以双向调用。</p>
<pre><code><![CDATA[
    a: [] # var a = []
    a.0: "hello" # a[0] = "hello"
    a.1: "world" # a[1] = "world"
    b: 100
    a.(b): "last" # a[b] = "last"

    b: {}
    b.scheme: "https"
    b."content-length": 123 # b["content-length"] = 123

    c: <> Math.random() # var c = function() { return Math.random(); }
]]></code></pre>
<h2>文件格式与外观</h2>
<p>后缀名为.lemo。</p>
<p>Lemo文件的外观：由版本行、语句、注释和无语义空白组成。语句是可以嵌套的。版本行和语句是有语义的，注释和无语义空白都是无语义的。</p>
<p>语句不是表达式，也不可以作为表达式。表达式不是语句，但可以作为语句，作为语句时称作表达式语句。有两种语句：表达式语句和命令语句。</p>
<p>类似CoffeeScript，在Lemo中，缩进是很重要的，它构成了嵌套。缩进可以用<code>&lt;&lt;</code>与<code>&gt;&gt;</code>代替。</p>
<p>类似CoffeeScript，多个并列语句可以通过分号<code>;</code>合并成1行，单行可以通过<code>\</code>拆分成多行。</p>
<p>空行，是指不含有字符的行。</p>
<p>空白行，是指不含有字符或只含有空白字符的行。</p>
<p>无语义空白，是指空白行，或者行右侧无意义的空白。</p>
<p>下文的所有描述，都是假设代码中的无语义空白已被去除。</p>
<p>大多数语句都是表达式语句，除了这些是命令语句：</p>
<ul>
    <li>:（冒号，表示赋值时）</li>
    <li>delete</li>
    <li>export（仅限于语句开头是export，所以不包括export as，但包括export...as）</li>
    <li>后置的if</li>
    <li>return</li>
    <li>throw</li>
</ul>
<p>给定一条语句，该语句所在级别的最大范围连续内容称作该语句所在的块，块不包括版本行。我们说某语句的子块，是指该语句的一级下属。我们说某块的子语句，也是指该块的一级下属。若某类语句的子块的子项可以是语句或注释，我们称这类子块是语句块。否则，称这类子块是非语句块。</p>
<p>这些块是语句块：</p>
<ul>
    <li>顶级块</li>
    <li>函数块</li>
    <li>then块</li>
    <li>else块</li>
    <li>try块</li>
    <li>catch块</li>
    <li>finally块</li>
</ul>
<p>其他块则都是非语句块，例如：</p>
<ul>
    <li>class块</li>
    <li>数组块</li>
    <li>对象块</li>
</ul>
<p>所有可以出现语句块的地方，都可以被替换为不嵌套的一条语句而仍然符合语法（有时需要加一个用来分隔的标志）。例如：</p>
<pre><code><![CDATA[
    if x = 5
        aaa()
        bbb()
        ccc()
]]></code></pre>
<p>这是合法的。如果我们把它替换成非块的形式：</p>
<pre><code><![CDATA[
    if x = 5 then aaa()
]]></code></pre>
<p>仍然符合语法。<code>aaa()</code>是<code>if</code>语句的子语句，没有“块”这一层。</p>
<p>语句块的子语句是从上往下执行。除顶级块外所有语句块都有值，若最后一个子语句是表达式，则为该表达式的值，若不是，则为<code>void</code>。</p>
<h2>缩进</h2>
<p>对于某一行B，若它的起始部分不属于字符串，它的缩进的效果是什么？依下面的步骤：</p>
<p>1. 强制连接：上一行A以<code>\</code>结尾吗？若否，则做下一步。若是，则执行：无论缩进如何，该行被解析为犹如被连接到上一行末尾并跳到5，若无法解析则跳到6。</p>
<p>2. 并列：上面存在一行A，满足B的缩进等于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接（术语解释：“被连接者”是指连接后的右面，“连接者”是指左面）吗？若否，则做下一步。若是，则执行：A的起始部分和B的起始部分被解析为并列关系并跳到5，若无法解析则跳到4。</p>
<p>3. 层级：上面存在一行A，满足B的缩进大于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进，且A没有被连接或被强制连接吗？若否，则做下一步。若是，则执行：A的结尾部分和B的起始部分被解析为层级关系并跳到5，若无法解析则跳到4。</p>
<p>4. 连接：上面存在一行A，满足B的缩进不小于A的缩进，且A和B之间无其他行或A和B之间的所有行的缩进都大于B的缩进吗？若否，则跳到6。若是，则执行：B被解析为犹如被连接到A的末尾所属语句的末尾并跳到5，若无法解析则跳到6。例如：</p>
<pre><code><![CDATA[
    if x = 5 and
    y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5
    and y = 5 then aaa()
]]></code></pre>
<p>或：</p>
<pre><code><![CDATA[
    if x = 5 and
        y = 5 then aaa()
]]></code></pre>
<p>都等价于：</p>
<pre><code><![CDATA[
    if x = 5 and y = 5 then aaa()
]]></code></pre>
<p>又例如：</p>
<pre><code><![CDATA[
    a.b <>
        aaa()
    .c()
]]></code></pre>
<p>等价于：</p>
<pre><code><![CDATA[
    a.b(<> aaa()).c()
]]></code></pre>
<p>5. 解析成功并退出。</p>
<p>6. 解析失败并退出。</p>
<p>缩进的规则很适合用来表示一些复杂的语句。例如，你既可以这样写：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match (<>
        s = @toLowerCase()
        text.includes(s)
    )
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>又可以这样写：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match <>
            s = @toLowerCase()
            text.includes(s)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>它们是等价的。<code>match</code>下面的两个块不互相隶属，但都属于<code>match</code>。</p>
<p>和CoffeeScript有一点不同，如下代码：</p>
<pre><code><![CDATA[
    a.b aaa
    .c()
]]></code></pre>
<p>CoffeeScript编译成<code>a.b(aaa).c()</code>，但我们还是按常规编译成<code>a.b(aaa.c())</code>。如果你想要达到CoffeeScript的效果，要加上括号：</p>
<pre><code><![CDATA[
    a.b(aaa)
    .c()
]]></code></pre>
<h2>版本行</h2>
<p>每个文件的第一行必须是版本行。版本行通常都写成一行，但写成多行也是允许的，但为了方便说明，还是说成“版本行”。版本行的一般语法：</p>
<pre><code><![CDATA[
    [...][lemo][...] [-]0.1.0[, (radical | compatible) | (slow new | fast new | manual new) | (node import | node export | node module | es module)]...
]]></code></pre>
<p>默认值为：</p>
<pre><code><![CDATA[
    compatible, fast new, es module
]]></code></pre>
<p>版本号后面的以逗号分隔的项不可重复。版本行的例子：</p>
<pre><code><![CDATA[
    0.1.0
    lemo 0.1.0
    lemo -0.1.0
    0.1.0, node module
    0.1.0, compatible, fast new
    0.1.0, compatible, fast new, node import
    0.1.0, radical, slow new
]]></code></pre>
<p>版本号必须写上。只要你写的版本号不大于安装的Lemo的版本号，该文件就会按照该版本的规范来运行，这是因为你安装的任何一个版本的Lemo都包括了（至少我们会尽量包括）所有历史版本的编译器。而这，是Lemo和其他语言的不同之处。你甚至可以在一个项目中，不同文件使用不同版本。</p>
<p>写上版本号还有个好处，就是你把某个文件交给别人时，他就知道文件是什么版本的，从而可以更好地修改。</p>
<p>本文只描述一个版本。</p>
<p>当你想把版本行写成多行时，版本号后面要加上括号，括号必须在第一行。版本号和括号之间可以有逗号，也可以没有逗号。括号之前还可以有<code>\</code>，也可以没有<code>\</code>。逗号的位置在<code>\</code>之前。例如：</p>
<pre><code><![CDATA[
    0.1.0 (
        radical
        node module
    )
]]></code></pre>
<p>多行应用于Shebang的例子（在Shebang中要加选项的话多行是必须的）：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0 \(
        radical
        node module
    )
]]></code></pre>
<p>单行应用于Shebang的例子：</p>
<pre><code><![CDATA[
    #!/usr/bin/env node node_modules/lemo/bin/lemo -0.1.0
]]></code></pre>
<p>当文件的后缀名不是.lemo或没有后缀名时，版本号前必须有<code>lemo</code>。当文件的后缀名是.lemo时，不必须，然而我们推荐加上<code>lemo</code>，因为对你的文本编辑器有用，方便它判断应该使用哪个语法包，使代码呈现正确的彩色。</p>
<p>激进模式和兼容模式的差异是：激进模式只允许单参数的函数（多参数和零参数都不允许），兼容模式没有这个限制。因此：</p>
<p>激进模式中，<code>@</code>表示JS的<code>arguments[0]</code>。兼容模式中，<code>@</code>表示JS的<code>arguments</code>。</p>
<p>激进模式中，定义或调用零参数的函数会实际使用单参数<code>void</code>（即JavaScript的<code>undefined</code>）。但兼容模式中，定义或调用零参数的函数会实际使用零参数。例如：激进模式中，<code>a()</code>会被编译成<code>a(undefined)</code>。兼容模式中，<code>a()</code>会被编译成<code>a()</code>。</p>
<p>激进模式中，定义或调用多参数的函数会产生编译错误。但兼容模式中，不会出错。</p>
<p>激进模式中，管道操作符把数组单参数分隔为两部分，而兼容模式中管道操作符把所有参数分隔为两部分。</p>
<p>激进模式中，<code>'</code>只能是二元的，而兼容模式中<code>'</code>还可以是一元的。</p>
<p>下文中，为求简便，如果写道“无参数”，也可指激进模式中的参数为<code>void</code>的情形。</p>
<p><code>fast new</code>是指创建类的实例不用加<code>new</code>，编译时会自动加进去，依据类名的首字母大小写，大写的加，小写的不加。但只能识别普通的表示法，像引号内的就不能识别，例如：</p>
<pre><code><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>slow new</code>是指创建类的实例不用加<code>new</code>，编译时也不会自动加进去，而是在运行时自动判断，依据它是不是es6的class或Lemo的类，是的加，不是的不加。因为运行时判断比较慢（尤其是判断是否是es6的class时只能先尝试不加然后看是不是出错，用到了try-catch，更慢），所以谨慎使用。而且它无法照顾到用普通函数写的类。</p>
<p><code>manual new</code>就是传统办法，创建类的实例需要加<code>new</code>。</p>
<p><code>node import</code>是指导入被编译成node的导入（即require）。<code>node export</code>是指导出被编译成node的导出（即exports和module.exports）。<code>node module</code>是两者都做。<code>es module</code>是两者都不做（即按照ES6的规范）。</p>
<p>编译后的代码是strict mode。</p>
<p>本文的示例是按照兼容模式写的，在激进模式下有些地方需要改写。</p>
<h2>函数</h2>
<p>函数的声明有2种方式：<code>-&gt;</code>和<code>&lt;&gt;</code>。<code>&lt;&gt;</code>是无参数时的简便方法。参数为1个时括号可省略，这有别于CoffeeScript。</p>
<pre><code><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>如果没有参数，那么必须使用如下一种：</p>
<pre><code><![CDATA[
    a: <> Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>兼容模式允许多参数，但必须要有括号：</p>
<pre><code><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>单参数如果是数组的话，可以使用类似解构赋值的形式：</p>
<pre><code><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p><code>@</code>取代了JS的<code>arguments</code>（兼容模式下），它是如此简便，在许多情况下，你会喜欢不带参数名。例如，我们可以写：</p>
<pre><code><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>参数可以有默认值：</p>
<pre><code><![CDATA[
    a: (x'ifvoid: 0, y'ifvoid: 0) -> x * y
]]></code></pre>
<p>有默认值的话，参数必须有括号。</p>
<p>如果是<code>'ifvoid</code>默认，则<code>'ifvoid</code>可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (x: 0, y: 0) -> x * y
]]></code></pre>
<p>甚至冒号前面的变量名也可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (:0, :0) -> @0 * @1
]]></code></pre>
<p>也等同于：</p>
<pre><code><![CDATA[
    a: ('ifvoid: 0, 'ifvoid: 0) -> @0 * @1
]]></code></pre>
<p>函数的调用有4种表示法：空格、小括号、中括号、大括号。</p>
<pre><code><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5) # only valid in compatible mode
]]></code></pre>
<p>多参数调用一定要加括号，这个CoffeeScript不同。只有单参数调用是可以不加括号的，零参数要加<code>()</code>。</p>
<p>CoffeeScript里面如果函数调用要传递的参数本身也是函数的话，如果它没有参数，那么可写成<code>abc -&gt; Math.random()</code>，但Lemo中绝对不能这么写，否则编译器会误以为这是一个参数为abc的函数。必须采用如下一种：</p>
<pre><code><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>激进模式会不会限制语言的表达力呢？我认为不会，因为我们可以用对象或数组作为参数，就像上面的例子那样，JSON本身已经十分方便了。</p>
<p>兼容模式中，我们还可以使用<code>'</code>来达到类似splat的效果：</p>
<pre><code><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>这两个是不同的：</p>
<pre><code><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>凡是函数都有一个返回值，值即为函数块的值，所以一般不需用<code>return</code>。但在函数中间要返回则需要用<code>return</code>。</p>
<p>不像CoffeeScript，我们没有胖箭头<code>=&gt;</code>。我认为JavaScript使<code>this</code>的含义可自定义是一种错误的设计，它应该始终指向当前对象。我们的函数和CoffeeScript的函数的对应关系如下：</p>
<ul>
    <li>类的方法和构造器（包括嵌套的类的方法和构造器）：CoffeeScript瘦箭头</li>
    <li>类的方法和构造器内部（不包括嵌套的类的方法和构造器，但包括嵌套的类的方法和构造器内部）：CoffeeScript胖箭头</li>
    <li>其余地方：CoffeeScript瘦箭头</li>
</ul>
<h2>赋值与声明</h2>
<p>用<code>:</code>、<code>as</code>。例如：</p>
<pre><code><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b = 4 ? alert "impossible!" # var b; if ((b = 3) === 4) {alert("impossible");}
]]></code></pre>
<p>注意，<code>:</code>不构成表达式，但<code>as</code>构成表达式。例如：</p>
<pre><code><![CDATA[
    abc: <> a: 1
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>void</code>而不是<code>1</code>。但</p>
<pre><code><![CDATA[
    abc: <> 1 as a
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>1</code>。</p>
<p>变量不用声明也不能声明，这是因为我们为变量赋值的机制和CoffeeScript相同，如果前面还未出现过则会编译成声明并赋值，如果已出现过则会编译成单纯赋值。</p>
<p><code>:</code>也支持数组解构赋值（不包括嵌套），例如：</p>
<pre><code><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>冒号的作用就是让左边的拥有右边的值。无论是对象中的冒号还是赋值中的冒号，含义相似。</p>
<p><code>:</code>支持对多标识符同时赋值，例如：</p>
<pre><code><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<p>还可以对包含子语句的语句用<code>as</code>，例如：</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        as f1

        x ->
            ddd(x)
            eee(x)
            fff(x)
        as f2
    ]
]]></code></pre>
<p>如上例显示，这种<code>as</code>和下一语句之间最好要有空行，不然不容易看清这个<code>as</code>是属于谁的。但我们也提供了你不空行时的好办法，就是加个<code>above</code>。</p>
<pre><code><![CDATA[
    [
        x ->
            aaa(x)
            bbb(x)
            ccc(x)
        above as f1
        x ->
            ddd(x)
            eee(x)
            fff(x)
        above as f2
    ]
]]></code></pre>
<p><code>above</code>对机器来说没有任何意义，不加也是合法的，但对人来说有意义。不过我的看法是，空行更直观些，打起来也更方便。</p>
<p>要注意，上面两个例子中<code>as</code>和上面的函数并不是两个并列的语句，而是一个语句。语句不能以<code>as</code>或<code>above as</code>开头。</p>
<h2>模块</h2>
<p>一个文件即是一个模块。和模块有关的语法有<code>import</code>、<code>export</code>、<code>'export</code>。</p>
<p><code>import</code>后面只能跟简单字符串（可以包含转义符，但不可以是经计算的）。这些都是正确的语法：</p>
<pre><code><![CDATA[
    import "./abc" as abc
    abc: import "./abc"
    import "abc"
    aaa: import "./abc.js".aaa()
    aaa: import("abc").aaa()
    import("\u0041")
]]></code></pre>
<p>这些是错误的语法：</p>
<pre><code><![CDATA[
    import "./a" + "bc"
    import("./a" + "bc")
    import "./\(filename)"
    import """abc"""
    import v"abc"
]]></code></pre>
<p>导出时，我们可以使用4种语法：<code>export</code>、<code>'export</code>、<code>export as</code>、<code>export ... as</code>。这些都是正确的语法：</p>
<pre><code><![CDATA[
    multiply'export: <> @0 * @1
    mp: (<> @0 * @1) export as multiply
    mp: <>
        @0 * @1
    above export as multiply
    mp: <> @0 * @1
    above export as multiply
    <> @0 * @1
    above export as multiply
    mp: (<> @0 * @1) as multiply'export
    abc export as def
    export abc as def
    export abc
    export <> @0 * @1
]]></code></pre>
<p>和赋值一样，这里的<code>above</code>也是可略的。</p>
<p>这些是错误的语法：</p>
<pre><code><![CDATA[
    abc export def
    export: abc
    export multiply: <> @0 * @1
    obj.multiply'export: <> @0 * @1
]]></code></pre>
<p>当语句以<code>export</code>开头，且<code>export</code>后除了一个表达式再无其他时，表示总的导出，类似于node中的<code>module.exports = ...</code>。文件中这种语句只能出现一次，而且若出现则不能含有其他形式的导出，否则必须产生编译错误。</p>
<p>不同于ES6，Lemo中的导入和导出不是必须出现在顶层。在任何地方出现，编译器会自动把导入编译到代码顶端，把导出编译到代码底端。但从内部原理来看，我们的模块导入导出还是基于ES6的，例如我们是静态导入，无法动态导入，这比Node要严格。当然，我知道有些场合可能需要动态导入，那你完全可以抛弃Lemo的原生模块语法，而用<code>Node</code>的<code>require</code>。</p>
<h2>字符串、正则表达式</h2>
<p>字符串受CoffeeScript启发，不同之处在于不用单引号、增加了支持原义字符串、不支持简单字符串的多行自动连接。</p>
<p>简单字符串：</p>
<pre><code><![CDATA[
    str: "Welcome to Lemo!"
]]></code></pre>
<p>复杂字符串：</p>
<pre><code><![CDATA[
    htmlStr: """
        <p>
            Welcome to "Lemo"!
        </p>
    """
]]></code></pre>
<p>简单字符串和复杂字符串的区别是：第一，复杂字符串中包含双引号字符更容易。第二，复杂字符串外面的引号不可以在字符串内部的行中，这导致复杂字符串内部第一个换行和最后一个换行是格式而不是字符，而简单字符串的第一个换行和最后一个换行是字符。</p>
<p>上例的复杂字符串其实等价于：</p>
<pre><code><![CDATA[
    htmlStr: "<p>
        Welcome to \"Lemo\"!
    </p>"
]]></code></pre>
<p>简单字符串的缩进是从引号的缩进的相同值开始算作字符，复杂字符串的缩进是从字符串内部除空行外缩进最小的一行的缩进的相同值开始算作字符。简单字符串内部的缩进不可以小于引号的缩进，复杂字符串内部的缩进不可以小于或等于引号的缩进。</p>
<p>我们不用单引号，因为我觉得你要想用单引号，有两种可能：一种是字符串很长，但这时可以用<code>"""</code>；一种是字符串很短，像<code>'"'</code>，这其实只增加了微小的可读性，我宁愿写成<code>"\""</code>。无论哪一种用单引号都没有明显优势，所以，还是别占用宝贵的符号资源为好。而且双引号是和JSON一致的。</p>
<p>也支持字符串插值，就像CoffeeScript，，不过我们使用<code>\(...)</code>。</p>
<pre><code><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>正则表达式我们用<code>r"..."</code>来表示。例如：</p>
<pre><code><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>正则表达式废除了<code>\</code>的大部分功能，除了两个：表示双引号字符仍然是用<code>\"</code>，在行尾连接仍然是用<code>\</code>。注意，JS中表示双引号可以直接用<code>"</code>，但在这儿必须用<code>\"</code>。</p>
<p>还可以表示带有标志的正则表达式：</p>
<pre><code><![CDATA[
    r"\d{3}-\d{3}-\d{4}"gim
]]></code></pre>
<p>这是简单正则表达式。我们还支持复杂正则表达式，例如：</p>
<pre><code><![CDATA[
    str.search(r"""
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    """)
]]></code></pre>
<p>复杂正则表达式的不同点是：空格和换行无意义，支持注释，支持字符串插值，表示双引号字符更简单，表示<code>#</code>需要用<code>\#</code>。字符串插值是用<code>#(...)</code>。</p>
<p>原义字符串是受C#启发，我们使用<code>v"..."</code>来表示，例如：</p>
<pre><code><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>原义字符串完全废除了<code>\</code>的功能，所以行末不能用<code>\</code>来连接。在原义字符串中表示双引号字符是用<code>""</code>而不是用<code>\"</code>。</p>
<p>还支持原义复杂字符串，用<code>v"""</code>来表示。</p>
<p>所以总结一下，凡是字符串起始符号<code>"</code>左边紧接着字母的，可以是表示字符串，也可以表示字符串经转换后的值。</p>
<p>正则表达式引号中间的内容本质上是字符串，这和JS和CoffeeScript都不同。就算是复杂正则表达式中的注释，本质上是属于字符串的，只是转换时去掉了而已。注意，转换是编译时而不是运行时，所以不影响效率。</p>
<p>还有一点和CoffeeScript不同，就是CoffeeScript中：</p>
<pre><code><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
    never mind how long precisely -- having little
    or no money in my purse, and nothing particular
    to interest me on shore, I thought I would sail
    about a little and see the watery part of the
    world..."
]]></code></pre>
<p>这会编译成多行自动连接，连接符是一个空格。但是我们不支持，因为我觉得这只适合西方语言。如果是中文，那加上空格可就错了。所以这个功能不好，应该老老实实用<code>\</code>来连接，是英文的话，前面加个空格。所以，在Lemo中，简单字符串、复杂字符串、原义字符串、正则表达式都是原样呈现多行的（除了首行和末行有些区别）。</p>
<h2>数组</h2>
<p>方括号的作用就是表示数组，没有其他用途。</p>
<p>点号的作用就是表示对象的字段。由于数组也是对象，所以JS中<code>arr[3]</code>我们改为<code>arr.3</code>，更一致。其实数组就是属性名为索引值的对象，刚知道时可能会惊讶，但确实是这样，可以用<code>Object.keys(arr)</code>验证这一论断。JS这点和别的语言不同，但不是糟粕，只要形式上变得一致就可以了。</p>
<p>当然，在和带小数点的数字同时出现时，会感觉别扭，这时建议加上括号。比较一下：</p>
<pre><code><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p>数组的表示法和CoffeeScript完全相同。</p>
<h2>对象</h2>
<p>对象的表示法和CoffeeScript基本相同，除了它必须加上大括号，不能省略。</p>
<h2>逻辑运算</h2>
<ul style="font-family: monospace;">
    <li>=</li>
    <li>/= (not =, not=, !=)</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>等号的作用就是判断相等，不用再考虑烦人的<code>=</code>、<code>==</code>、<code>===</code>之间的区别。</p>
<p><code>/=</code>表示不相等，也可写作<code>not =</code>，中间的空白可有可无。考虑程序员们的习惯，目前也支持使用<code>!=</code>，但是建议尽量少用，因为以后有可能会删掉。我觉得单独的感叹号用于表示<code>not</code>是不合适的，<code>not</code>已经够简洁了。如果单独的感叹号在未来有语义（目前还被尘封），那么<code>!=</code>就有可能会产生歧义，所以那时就有可能删除。</p>
<p>和CoffeeScript一样，我们也支持这种链式比较：</p>
<pre><code><![CDATA[
    if 200 <= statusCode < 300
        console.log "success"
]]></code></pre>
<p>但是我们的限制比CoffeeScript多，只有同一个方向的才可以链式比较。像这种就不支持：</p>
<pre><code><![CDATA[
    if a < b > c
        console.log "success"
]]></code></pre>
<h2>条件</h2>
<p>用<code>if</code>、<code>?</code>、<code>then</code>、<code>else</code>、<code>|</code>。例如：</p>
<pre><code><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
也可以并成一行：
<pre><code><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>甚至</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code>和<code>then</code>等价，<code>|</code>和<code>else</code>等价，这条规则不仅限于<code>if</code>语句，在所有地方通用。下文提到的它们任何一个的规则也适用于它的等价方。</p>
<p>条件前置时，<code>if</code>可写可不写，而<code>then</code>则当有<code>then</code>块时可写可不写。</p>
<p>当<code>then</code>后面是命令语句时，<code>then</code>也可省略（这也适用于模式匹配）。例如：</p>
<pre><code><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>但是要注意，条件前置时无论怎样省略，<code>if</code>和<code>then</code>必须至少出现一个。</p>
<p>如果<code>else</code>块省略，那么则当<code>else</code>时整个<code>if</code>表达式的值为<code>void</code>。</p>
<p>条件还可以后置，这时就只能用<code>if</code>，例如：</p>
<pre><code><![CDATA[
    alert("a is true!") if a # if (a) {alert("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p>当条件后置时，<code>if</code>并不作为操作符，整体上并不是个表达式。所以如果有条件后置的语句在函数的末尾，则函数返回的将是void。</p>
<p>还有一点和CoffeeScript不同，就是当碰到分号时：</p>
<pre><code><![CDATA[
    if x > 100 then aaa(); bbb()
]]></code></pre>
<p>CoffeeScript是把<code>aaa(); bbb()</code>全作为子语句，这看上去似乎是硬插入一条规则，很不统一，而且我们已有了专门的符号，可以写成：</p>
<pre><code><![CDATA[
    if x > 100 << aaa(); bbb() >>
]]></code></pre>
<p>所以这条规则在我们这里作废。Lemo里，分号能穿越一切障碍物，除非超过了括号或<code>&lt;&lt;</code>、<code>&gt;&gt;</code>限定的范围。</p>
<h2>模式匹配</h2>
<p><code>match</code>可以看成是一个增强版<code>switch</code>，它称为模式匹配。例如：</p>
<pre><code><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>上面只是最普通的模式匹配，<code>day</code>是输入，1、2、3……称作模式。它不但比JavaScript的switch强大，甚至比CoffeeScript的switch还强大，看看这个：</p>
<pre><code><![CDATA[
chessBoard: (pos) -> match [pos.x, pos.y]
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>这个称为数组模式。它不是简单地比较两个数组是否相等（那样会始终不相等，因为不是同一个引用），而是检查数组（直接，非嵌套）中每个元素是否相等。当模式以<code>[</code>开头时，适用数组模式。注意一定要直接写出<code>[</code>，绝不能用变量替代，像这样是没用的：</p>
<pre><code><![CDATA[
    a: [0, 0]
    b: [0, 1]
    c: [4, 5]
    chessBoard: (pos) -> match [pos.x, pos.y]
        a ? "king"
        b ? "pawn"
        c ? "queen"
        |   "empty"
    piece: chessBoard {x: 4, y: 5} # will be "empty"
]]></code></pre>
<p>模式匹配中的“比较”默认是用<code>=</code>，还可以用其他比较运算符，例如：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100 ? "unsupported"
        200 ? "informational"
        300 ? "success"
        400 ? "redirect"
        500 ? "client error"
        600 ? "server error"
        |     "unsupported"
]]></code></pre>
<p><code>else</code>可以跟前面的并在一起，此时用<code>or else</code>，但该项不能有<code>then</code>。在模式中，<code>or</code>这个关键字若不作为运算符使用，可以简写为逗号<code>,</code>，所以上面的例子可以写成：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100, | "unsupported"
        200  ? "informational"
        300  ? "success"
        400  ? "redirect"
        500  ? "client error"
        600  ? "server error"
]]></code></pre>
<p>用<code>or else</code>的时候<code>or</code>还可以省略，所以还可以写成：</p>
<pre><code><![CDATA[
    message: match statusCode <
        100 | "unsupported"
        200 ? "informational"
        300 ? "success"
        400 ? "redirect"
        500 ? "client error"
        600 ? "server error"
]]></code></pre>
<p>不但可以用比较运算符，还可以自定义比较函数，例如：</p>
<pre><code><![CDATA[
    text: "This is a dog."
    speak: match <> text.includes(@)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>当<code>match</code>后紧接的是函数时，则被识别成自定义比较函数。要直接写出<code>-&gt;</code>或<code>&lt;&gt;</code>，绝不能用变量替代，这一点和数组模式相似。</p>
<p>还有or模式和and模式。or模式我们会经常用到，例如：</p>
<pre><code><![CDATA[
    day: "Tue"
    action: match day
        "Sat", "Sun" ? "have a rest"
        |              "work"
]]></code></pre>
<p>and模式则不常用，但也有例子：</p>
<pre><code><![CDATA[
    array: ["a", "c", "b", "d"]
    message: match <> array.includes(@)
        "a" and "b" and "c" ? "The array includes all of the first 3 letters."
        "a"                 ? "The array includes a."
        "b"                 ? "The array includes b."
        "c"                 ? "The array includes c."
        |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>由此可知，or和and作为运算符在模式中使用是有限制的，它作为运算符时必须出现在括号内，否则会被认为是模式。所以真的有这个需求的话，要用个括号包起来。不过这两个运算符出现在模式中好像也没有什么用。</p>
<p>作为模式使用时要么全是<code>or</code>，要么全是<code>and</code>，两个不能在一个模式中一起出现，否则编译器会无法判断。括号内的无此限制。</p>
<p>注意<code>or else</code>是一种特殊的写法，并不属于or模式，所以<code>or else</code>可以和<code>and</code>在一个模式中一起出现。</p>
<p>和<code>if</code>一样，可以有<code>then</code>块，这时就不用写<code>then</code>了：</p>
<pre><code><![CDATA[
    day: 3
    match day
        6
            go bingo
            go dancing
        7
            go church
        |
            go work
]]></code></pre>
<p>可以看出，即便是模拟传统的<code>switch</code>，依然比<code>switch</code>简洁。</p>
<h2>循环</h2>
<p>循环其实并不符合函数式编程的理念，我们没有循环。但我的mate库提供了全局函数repeat来模拟循环。为方便起见，本文中的“循环”一般指repeat。例子：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>迭代器返回<code>false</code>则表示跳出循环，相当于JS的<code>break</code>：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        if i > 5 return false
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>不设次数则表示永远，相当于JS的<code>while (true)</code>：</p>
<pre><code><![CDATA[
    repeat ->
        if abc() return false
        doSomething()
]]></code></pre>
<p>Mate的地址：https://www.npmjs.com/package/mate</p>
<h2>类</h2>
<p>和类有关的关键字有<code>class</code>、<code>super</code>、<code>static</code>、<code>new</code>、<code>me</code>、<code>Me</code>。例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me.name: @0

        move: meters ->
            alert me.name + " moved \(meters)m."

    Snake: class from Animal
        move: <>
            alert "Slithering..."
            super 5

    Horse: class from Animal
        move: <>
            alert "Galloping..."
            super 45

    sam: Snake "Sammy the Python"
    tom: Horse "Tommy the Palomino"

    sam.move()
    tom.move()
]]></code></pre>
<p>我们使用比传统更纯粹的形式：让赋值功能从class剥离出来，使用表达式而非语句。</p>
<p>类的声明方式比较像CoffeeScript。但我们的更严格。我们多了getter and setter功能，以及<code>constructor:</code>简写成<code>new:</code>。在Lemo中，类的所有声明的子项都必须是以冒号的形式。</p>
<p>JS的<code>this</code>我们用<code>me</code>代替。我们还有一个关键字<code>Me</code>，M大写，表示<code>me</code>所在的类。当静态调用时<code>Me</code>和<code>me</code>相同，但建议使用<code>Me</code>，因为大写比较像类。</p>
<p>getter和setter的例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p><code>'get</code>和<code>'set</code>一看就明白。这里的亮点是<code>me._name</code>，它编译成的JS不是像你猜测的那样是<code>this._name</code>，而是<code>this[_name]</code>，其中<code>_name</code>是Symbol。编译器一碰到<code>me.</code>，并且后面是以<code>_</code>开头的话，即这样编译。</p>
<p>这被称作“防冲突字段”，可以把它近似看成是私有字段。防冲突字段的好处不是外部无法访问，外部虽然无法通过对象的属性直接访问，但可以间接访问，最大的好处是继承类可以放心地使用同名的防冲突字段，而不用担心会覆盖，这在类关系很复杂的大型项目中尤其重要。因为这些字段不属于API，通常别的开发者是不会告诉你是怎样用的，如果你继承别人写的类，有可能你的私有字段正好重名，类的行为就被破坏了。</p>
<p>以<code>_</code>开头的字段名还可以出现在字段的声明中，例如：</p>
<pre><code><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>字段的声明中只要是以<code>_</code>开头的，便自动成为防冲突字段。</p>
<p>创建实例时无需使用new，因为其实JS的new是多余的，如果一个函数只能被当作类来使用，肯定会加new。所以在Lemo中，只要这被识别为一个类，那么当被作为函数调用时，编译出来的就会自动加上new。反之，如果不是类，编译出来的就不会加上new。具体的识别方法由版本行指定。当然，罕见的情况下，某个库的函数名可能会不符合约定，造成被识别为类，这时可以用<code>nonew</code>关键字，语法上和<code>new</code>一样。</p>
<p><code>Number</code>、<code>String</code>、<code>Boolean</code>始终被识别为不是类，无论编译选项如何。</p>
<p>CoffeeScript对于静态字段是使用<code>@property: value</code>，我们使用的是<code>static</code>关键字，即<code>static property: value</code>。</p>
<p>防冲突字段也适用于静态字段，区别是使用的不是<code>me.</code>而是<code>Me.</code>。</p>
<p>有的时候我们想写静态构造函数，也可以，<code>static</code>后面不要跟任何名称即可，例如：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result[0]
            Me.part2: result[1]
]]></code></pre>
<p>静态构造函数内的<code>me.</code>和<code>Me.</code>都指向当前闭包所在的类，即这个类本身，而不是当前对象的类。</p>
<p>不要在类的方法或构造器内部为另一个对象的原型方法赋值。例如这样不合理（虽然不会出错）：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>这是因为在该原型方法内使用<code>me</code>的话表示不了你想要表示的东西。正确的方法是把它写在类的外面。至于嵌套类，是可以的，因为编译器能识别<code>class</code>关键字，从而做出对于<code>me</code>的正确解释。不过嵌套类好像用处也不大，建议类与类的关系还是扁平为好。</p>
<p>只要类有实例化需求，就要避免取非大写开头的名称，否则会影响编译器判断。如果类的所有需求都是静态，那么就任意了。</p>
<h2>上下文</h2>
<p>JavaScript表示上下文的只有this和arguments，我们有5个，分别是：</p>
<ul>
    <li>当前对象：<code>me</code></li>
    <li>当前对象的类：<code>Me</code></li>
    <li>闭包中的当前函数：<code>fun</code></li>
    <li>当前参数：<code>@</code></li>
    <li>赋值中冒号左边的标识符的旧值：<code>self</code></li>
</ul>
<p><code>@</code>后面的点号可以省略，除非点号后面跟<code>(</code>，或者<code>"</code>、<code>v"</code>、<code>r"</code>之类的字符串或字符串扩展。</p>
<h2>异常</h2>
<p>用<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>，具体实现和CoffeeScript几乎完全相同。例如：</p>
<pre><code><![CDATA[
    try
        allHellBreaksLoose()
        catsAndDogsLivingTogether()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<p>唯一的不同是：若<code>throw</code>后面啥都没有，不是语法错误，而是：若在catch块内则编译成<code>throw catchExceptionVar</code>，若不在catch块内则编译成<code>throw new Error()</code>。</p>
<h2>管道</h2>
<p>管道操作符是<code>|></code>。例子：</p>
<pre><code><![CDATA[
    u = require("underscore")
    [3, 4, 5] |> u.map x -> x * 2 |> u.max
]]></code></pre>
<p>管道使我们使用underscore函数库可以一种人类习惯的顺序来书写，我们再也不用这样写了：</p>
<pre><code><![CDATA[
    u = require("underscore")
    u.max(u.map([3, 4, 5], x -> x * 2))
]]></code></pre>
<p>还有一种运算符<code>::</code>，称之为“胖点”，专门应用于含有管道运算符的表达式，如果你想让管道和点号混合，胖点能提供更强的可读性。例如：</p>
<pre><code><![CDATA[
    [3, 4, 5] |> u.map x -> x * 2 :: map x -> x + 1 |> u.max
]]></code></pre>
<p>相当于：</p>
<pre><code><![CDATA[
    (([3, 4, 5] |> u.map x -> x * 2).map x -> x + 1) |> u.max
]]></code></pre>
<p>所以胖点基本就是点号，只不过它的优先级比较低，和管道运算符相同。而且看起来比较“胖”，和管道运算符比较接近，所以比较舒服。</p>
<h2>异步</h2>
<p><code>'wait</code>类似C#的await，使异步看上去像同步一样（然而不改变其异步的本质），所以它超越了promise。考虑这样一个JS：</p>
<pre><code><![CDATA[
    abc().then(function(x){
        return x.def();
    })
    .then(function(x){
        return x.ghi();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>我们现在可以写成：</p>
<pre><code><![CDATA[
    console.log abc()'wait.def()'wait.ghi()'wait
]]></code></pre>
<p>一旦代码有<code>'wait</code>，那么代码所在的函数（直接所在，非嵌套）就被编译成异步函数。我们不用async关键字声明异步函数，这个关键字根本多余。</p>
<p><code>'wait</code>针对的要么是promise，要么是别的异步函数的返回值。异步函数的返回值是被编译成一种特殊的生成器对象，我们将其称为任务。注意，生成器对象不是生成器函数。</p>
<p>在异步函数内部，每执行到<code>'wait</code>，会进入等待，直到该promise或任务有了结果，才继续往下执行。</p>
<p>网上已有文章介绍如何用yield来实现异步，那我们为什么不直接用yield，要发明一个新的符号？因为：</p>
<ul>
    <li>yield的本来意思是“产出”，用来表示异步显得怪怪的。</li>
    <li>yield是前置的，但这里其实应该后置。试想，前面的例子翻译成yield会是什么样？<code>var result = yield (yield (yield abc()).def()).ghi();</code>多层括号，前面3个yield，多难看？而且从时间顺序来说也应该后置。其实C#的await也应该是后置，它也弄得不好。是什么时候wait？是promise函数或异步函数执行完后wait，而不是wait之后再执行。注意promise函数执行完不表示promise有了结果，promise函数本身的执行是同步的。</li>
</ul>
<p>异步和管道结合的例子：</p>
<pre><code><![CDATA[
    x: data |> lib.process1'wait |> lib.process2'wait
    y: data |> lib.remoteCombine(anotherData1)'wait |> lib.remoteCombine(anotherData2)'wait
    console.log(x, y)
]]></code></pre>
<p>调用异步函数也可以不加<code>'wait</code>，当调用方不需要等待promise或任务出结果的时候。</p>
<p>用<code>'wait</code>调用异步函数的例子：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
    task()'wait
    console.log "success"
]]></code></pre>
<p>不用<code>'wait</code>，也可以调用异步函数并达到相同的目的：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
        console.log "success"
    task()
]]></code></pre>
<p>注意，不用<code>'wait</code>调用异步函数的时候，异步函数执行到第一个<code>'wait</code>的位置之前返回调用方。下面的例子说明了先后顺序：</p>
<pre><code><![CDATA[
    task: <>
        console.log "stage 1"
        aaa()'wait
        console.log "stage 3"
        bbb()'wait
        console.log "stage 4"
    task()
    console.log "stage 2"
]]></code></pre>
<p>其实用<code>'wait</code>调用异步函数的时候也是异步函数执行到第一个<code>'wait</code>的位置之前返回调用方，只不过调用方也在等待，看起来就像没有返回一样。</p>
<p>异步和<code>do</code>结合的例子：</p>
<pre><code><![CDATA[
    largeTask: <>
        do'wait <>
            aaa()'wait
            bbb()'wait
        do'wait <>
            ccc()'wait
            ddd()'wait
        do'wait <>
            eee()'wait
            fff()'wait
]]></code></pre>
<h2>存在</h2>
<p>这几个关键字或操作符和“存在性”有关<code>'void</code>、<code>'null</code>、<code>'ok</code>、<code>'ifvoid</code>、<code>'ifnull</code>。</p>
<p>首先我们经常碰到这样的要求：要检查某个变量名是否是已定义，但又不能引发异常。JS中只能用<code>typeof a === "undefined"</code>。在Lemo中我们可以用更紧凑的<code>a'void</code>。</p>
<p><code>a'null</code>，就相当于<code>typeof a === "object" &amp;&amp; a === null</code>，也不会引发异常。如果直接写<code>a = null</code>的话是有点问题的，如果它既不是null又没定义，就会引发异常。</p>
<p><code>a'ok</code>，意思就是a既不是void，也不是null。</p>
<p><code>'ok</code>还可以和点号结合起来使用，<code>'ok.</code>等同于CoffeeScript的<code>?.</code>，例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.winner?.address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip = lottery.winner'ok.address'ok.zipcode
]]></code></pre>
<p><code>'ok</code>还可以和函数调用结合起来使用，和CoffeeScript的<code>?(...)</code>一样。例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner?().address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner'ok().address'ok.zipcode
]]></code></pre>
<p><code>'ifnull</code>和<code>'ifvoid</code>必须后面跟冒号。例如：</p>
<pre><code><![CDATA[
    a'ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a'ifvoid: 8 # if (a === undefined) {a = 8;}
]]></code></pre>
<h2>'</h2>
<p><code>'</code>的形式有两种，一种是一元<code>'</code>，一种是二元<code>'</code>。一元<code>'</code>即函数的单参数变体，兼容模式专用。其他的都是二元<code>'</code>。</p>
<p>编译器如何判断某个<code>'</code>是一元还是二元？看<code>'</code>后面紧跟的字符。如果是数字或字母，则是二元，否则（例如是符号、空格或根本没有字符）要么是一元，要么无法解析。</p>
<p>所以这两者是一样的：</p>
<pre><code><![CDATA[
    a'void
    a 'void
]]></code></pre>
<p>但这个不一样：</p>
<pre><code><![CDATA[
    a' void
]]></code></pre>
<p>为了可读性，一元的<code>'</code>前面的那个字符不能是空白。像这个就是非法的，必须无法解析：</p>
<pre><code><![CDATA[
    a ' void
]]></code></pre>
<p>有些情况下二元<code>'</code>的第一个算元可以省略，例如函数参数默认值中的变量名，但是它仍然属于二元。</p>
<h2>in</h2>
<p><code>in</code>的用法和CoffeeScript几乎完全相同，当然，如果要表示否定，可以用<code>not in</code>，不能用<code>!in</code>。</p>
<h2>is</h2>
<p><code>is</code>表示左边是右边的类型，类似于JavaScript的<code>instanceof</code>，但又有些区别，它还能判断原始类型，可以说结合了<code>instanceof</code>和<code>typeof</code>。当右边是<code>Number</code>、<code>Boolean</code>、<code>String</code>（必须严格表示为这3个之中的1个，不能是引用）时使用<code>typeof</code>。</p>
<pre><code><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>与<code>in</code>相似，<code>is</code>表示否定时也是可以用<code>not is</code>，不过也可以使用更顺眼的<code>isnt</code>，但切记，绝不能用<code>is not</code>。</p>
<h2>delete</h2>
<p><code>delete</code>和JavaScript中的稍有不同。它不再是一个表达式。这是因为在JavaScript strict mode中并没有值为false的情况，而是抛出异常。既然我们都是用strict mode，所以没必要弄成表达式。</p>
<h2>rem和mod</h2>
<p><code>rem</code>即是JavaScript的<code>%</code>。<code>mod</code>是另一种求余，正负号和除数相同，只要除数是正数，结果就不为负，所以这种求余适用范围可能更广一些。<code>a mod b</code>相当于JavaScript的<code>(a % b + b) % b</code>。</p>
<h2>do</h2>
<p><code>do</code>关键字的用法和CoffeeScript完全相同。</p>
<h2>注释</h2>
<p>使用<code>#</code>和<code>###</code>，和CoffeeScript完全一样。</p>
<h2>插入JavaScript</h2>
<p>使用<code>js"</code>。例如：</p>
<pre><code><![CDATA[
    hi = js"function() {
        return [document.title, 'Hello JavaScript'].join(': ');
    }"
]]></code></pre>
<p>它完全废除了<code>\</code>的功能，双引号也无法在其中用任何变通的办法表示（否则会有代价），不过妙在JS也支持单引号。如果必须用双引号，我们也支持<code>js"""</code>。</p>
<h2>&lt;&lt;和&gt;&gt;</h2>
<p>通常来说，把一行拆成几行会增加可读性。但有的时候恰恰相反，你会发觉把几行特别短小的代码合并成一行反而更好看，特别是当你有很多这样的“几行”的时候。例如：</p>
<pre><code><![CDATA[
    A: class << aaa: 1 >>
    B: class << bbb: 1 >>
    C: class << ccc: 1 >>
    D: class << ddd: 1 >>
    E: class << eee: 1 >>
]]></code></pre>
<p>和这个做对比：</p>
<pre><code><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>这时<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的威力就体现出来了。<code>&lt;&lt;</code>表示接下去的代码缩进一级，<code>&gt;&gt;</code>表示还原。</p>
<p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>必须在1行内结束。也就是说，只能把多行合并成1行，无法把多行合并成2行。</p>
<p>这两个符号和分号结合使用很方便，各司其职，分号用来合并并列的语句，这两个符号用来合并有层级的语句。</p>
<h2>关键字</h2>
<p>关键字不能作为变量名。</p>
<ul style="font-family: monospace;">
    <li>above</li>
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>export</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>import</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>rem</li>
    <li>return</li>
    <li>self</li>
    <li>static</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>保留字</h2>
<ul style="font-family: monospace;">
    <li>con</li>
    <li>elif</li>
</ul>
<h2>内置函数</h2>
<ul style="font-family: monospace;">
    <li>repeat</li>
</ul>
<h2>符号</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>"""</li>
    <li>v"</li>
    <li>r"</li>
    <li>r"""</li>
    <li>js"</li>
    <li>js"""</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>!=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'void</li>
    <li>'null</li>
    <li>'ok</li>
    <li>'ifvoid</li>
    <li>'ifnull</li>
    <li>'get</li>
    <li>'set</li>
    <li>'export</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
</ul>
<h2>运算符优先级</h2>
<p>运算符必须至少有一个算元（凡是算元都是表达式），并且运算结果是表达式。不过也不是所有运算符都有优先级。算元必须占满该行剩余部分（除非用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>）的运算符（即通常分多行写的）就没有优先级，例如<code>match</code>和<code>class</code>。下面表格中，a、b、c表示算元，x、y、z表示其他组成部分。</p>
<table>
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="5">13 left-to-right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>import</td>
        <td><code>import "x"<br/>import("x")</code></td>
    </tr>
    <tr>
        <td rowspan="2">12 left-to-right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>export as</td>
        <td><code>a export as x</code></td>
    </tr>
    <tr>
        <td>11 left-to-right</td>
        <td>Function Call</td>
        <td><code>a(b)</code></td>
    </tr>
    <tr>
        <td rowspan="3">10 right-to-left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td>9 right-to-left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="4">8 left-to-right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td rowspan="2">7 left-to-right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">6 left-to-right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="6">5 left-to-right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td>4 left-to-right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>3 left-to-right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td rowspan="2">2 right-to-left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>1 right-to-left</td>
        <td>Conditional</td>
        <td><code>if a then b else c<br/>a ? b | c</code></td>
    </tr>
    <tr>
        <td rowspan="2">0 left-to-right</td>
        <td>Pipe</td>
        <td><code>a |&gt; x</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
</table>
<h2>例子</h2>
<pre><code><![CDATA[
    # Assignment:
    number:   42
    opposite: true

    # Conditions:
    number: -42 if opposite

    # Functions:
    square: <> @ * @

    # Arrays:
    list: [1, 2, 3, 4, 5]

    # Objects:
    math: {
        root:   Math.sqrt
        square: square
        cube:   <> @ * square @
    }

    # Existence:
    alert "I knew it!" if elvis exists

    # Array comprehensions:
    cubes: list.map <> math.cube @
]]></code></pre>
<h2>常见问题</h2>
<p>问：为啥没有正则表达式符号？</p>
<p>答：正则表达式完全可以用<code>r"</code>来表示。</p>
<p>问：为啥没有位操作符？</p>
<p>答：首先，Lemo作为高级语言，没必要支持。其次，JavaScript的位操作是专门针对32位数字的，这本身就不合理。</p>
<p>问：为啥没有生成器？</p>
<p>答：生成器是适合特定用途的，似乎普适性还不够。至于缩短代码长度？加一个类库也可以达到这个目的，干嘛非得改动语言层面呢？至于在异步操作中的用途，Lemo也已经有了更好的替代方法。</p>
<p>问：为啥复杂字符串的缩进必须大于引号处的缩进？等于也不行吗？</p>
<p>答：如果允许等于或小于，就有可能造成编译器误判，当你字符串中某行行首正好是3个连续引号的时候。当然这种可能性很小，那如果是原义复杂字符串呢？只要需要表示2个引号时就必须写4个引号了。</p>
<p>问：为啥函数除了箭头符号以外还要弄个菱形符号？</p>
<p>答：我的目标是消除CoffeeScript中参数两边的括号。但是如果没有括号的话会产生歧义。所以我就想出了这个办法，如果不加括号，那就必须为1个参数。那零个参数怎么办？就再造一个符号呗。至于多个参数，就必须加括号，不过多参数并不在我的理想化（即激进模式）的构想当中，所以这也可以接受。再有一个原因，就是CoffeeScript用箭头表示零参数的话看上去既别扭又误导，箭头嘛，感觉应该左右都有东西才对。</p>
<p>问：既然如此，那为啥激进模式不废除箭头符号？反正有<code>@</code>可以用。</p>
<p>答：激进模式中，大多数情况下确实没必要给参数取名，但当你有多层函数，内层调用外层参数的时候，取名就有必要了。</p>
<p>问：为啥保留字那么少？</p>
<p>答：很多语言都有很多保留字，但我觉得你设计语言的时候预先定义好未来的功能，那未来有可能是你没料到的。我们在版本行使用版本号，也达到了“安全”的目的，因为可以保证只要你不修改版本号，就不会出现兼容性问题。</p>
<p>问：不支持<code>var</code>是受CoffeeScript启发，但为啥不支持ES6的<code>let</code>和<code>const</code>？</p>
<p>答：我的理念是，一名程序员也许不熟悉正在开发的文件之外的其他文件，但是一般都会熟悉这个文件当中的其他区域。<code>let</code>提供块级的保护，但是只要你熟悉的不是只是这个块，你完全可以使用一个不同的变量名。块级保护太小了，函数级保护已经足够坚固。否则的话语言本身的复杂度也会增加。<code>let</code>和CoffeeScript风格之间也有矛盾。至于<code>const</code>，我觉得理念有问题，<code>const</code>只是针对常量而已，而我们让某个东西不可变，不是防自己改，是防别人改。通常是自己做了个库，别人使用时，在运行时可能会乱改内部逻辑。变量仅自己可见，别人改不了，又何必成为常量？真正要保护的其实是对象的属性或方法，这个<code>const</code>却无法做到。可以通过<code>Object.defineProperty</code>来做到。但要动就得动包括原生对象在内的所有的对象，让方法都变得坚固（即变成类似静态语言的样子），这工作量太大了，可行性也值得怀疑，所以目前暂不做。</p>
<p>问：为何不支持对象解构赋值和复杂数组的解构赋值？</p>
<p>答：对象解构赋值过于复杂。它符合了人类一部分直觉，但违反了人类另一部分直觉，导致一开始根本就看不懂。复杂数组的解构赋值是中等复杂，以后也许会支持。至于对象解构赋值，以后即使支持，语法也要改得更自然。</p>
<p>问：为什么arguments用<code>@</code>表示？</p>
<p>答：首先，<code>@</code>形状也像个a。其次，<code>@</code>是符号中看上去最不像符号的，我们经常会使用孤立的<code>@</code>作为一个表达式，这时如果用其他符号，会显得不像个表达式，就不舒服了。</p>
<p>问：为什么以多参数调用函数一定要加括号？CoffeeScript不是可以不加吗？</p>
<p>答：多参数要用到逗号，不加括号的话，逗号到底分隔什么，不容易看清楚，大多数时候违反人类直觉。而且因为我觉得激进模式更完美，如果多参数可以不加括号，就有些鼓励人们采用兼容模式了。</p>
<p>问：<code>@</code>很好用，如果catch的上下文也能用一个符号表示就好了。</p>
<p>答：本来我考虑再用个新的符号来指代子语句内的上下文，不仅限于catch，但想想，不宜。用<code>@</code>时你很容易看清某个<code>@</code>所对应的是哪个函数，因为函数符号很好辨认。但子语句仅有的特征是缩进，而缩进我们是用得非常多的，很容易这个新符号的意思会变来变去，导致你搞混。如果这个新符号仅限于catch，又适用面太小。</p>
<p>问：<code>as</code>为何不能用逗号同时赋值？</p>
<p>答：若支持，像这个表达式<code>[aaa as a, bbb]</code>就容易产生歧义。</p>
<p>问：保留旧版本的编译器，那岂不越来越庞大？好恐怖！</p>
<p>答：其实也没那么恐怖，我们在做Lemo的时候会采取一些手段，使增量不那么大。</p>
<p>问：真的所有旧版本的编译器都包括吗？</p>
<p>答：我们尽量包括。但如果我们发现某个旧版本有安全漏洞，那么我们则会删掉。若不存在与代码相同版本的编译器，编译的时候会出现警告，同时会自动用新版本的编译器编译。</p>
<p>问：CoffeeScript链式调用不用加括号，这里为啥要加括号？</p>
<p>答：CoffeeScript其实是硬生生加了条规则，这会破坏语法的统一，而且虽然在一部分需求中更简洁了，但当有另一部分需求的时候却更复杂了。所以我决定不用这套方法。</p>
</body>
</html>
