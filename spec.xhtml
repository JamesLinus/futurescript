<!DOCTYPE html>
<html xml:lang="zh-Hans" xmlns="http://www.w3.org/1999/xhtml" style="font-size: 13pt;">
<head>
    <title>Less and more - Lemo语言 0.1.0</title>
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/base.css" type="text/css" />
    <link rel="stylesheet" href="http://zhanzhenzhen.github.io/essay-themes/simplified-chinese-modern.css" type="text/css" />
    <style type="text/css"><![CDATA[
        table {
            border-collapse: collapse;
        }
        table, td, th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
    ]]></style>
    <script src="http://zizisoft.com/doc-html.js" type="text/javascript" />
</head>
<body>
<h1>Less and more - Lemo语言 0.1.0</h1>
<p>詹臻臻 zhanzhenzhen@hotmail.com</p>
<h2>概要</h2>
<p>JavaScript实在是一门很怪的语言。它早年加入了很多无用的功能，不幸的是，出于兼容性考虑，这些功能永远都不能被删掉。另一方面，JavaScript却缺少很多真正有用的功能。当然，刚刚发布的 ECMAScript 6th 补足了大部分缺少的东西，但代价是显得臃肿不堪。如果有一门新的语言，它只继承JavaScript最精华的部分呢？JavaScript最精华的部分是什么？我觉得是JSON肯定包括在内，其他的就不多了。下面介绍Lemo语言，它编写的代码可以被JS调用。但反过来则不尽相同，如果使用了激进编译选项，那么大部分传统JS无法被Lemo代码所调用。但如果使用兼容选项，那么可以双向调用。</p>
<pre><code><![CDATA[
    a: [] # var a = []
    a.0: "hello" # a[0] = "hello"
    a.1: "world" # a[1] = "world"
    b: 100
    a.(b): "last" # a[b] = "last"

    b: {}
    b.scheme: "https"
    b."content-length": 123 # b["content-length"] = 123

    c: <> Math.random() # var c = function() { return Math.random(); }
]]></code></pre>
<h2>详细</h2>
<h3>文件格式</h3>
<p>后缀名为.lemo。第一行必须符合如下语法：</p>
<pre><code><![CDATA[
    v0.1.0[, (radical | compatible) | (slow new | fast new | manual new) | common]...
]]></code></pre>
<p>默认值为：</p>
<pre><code><![CDATA[
    compatible, fast new
]]></code></pre>
<p>版本号后面的以逗号分隔的项不可重复。头行的例子：</p>
<pre><code><![CDATA[
    v0.1.0, compatible, fast new
    v0.1.0, compatible, fast new, common
    v0.1.0, radical, slow new
]]></code></pre>
<p>激进模式和兼容模式的差异是：激进模式只允许单参数的函数（多参数和零参数都不允许），兼容模式没有这个限制。因此：</p>
<p>激进模式中，定义或调用零参数的函数会实际使用单参数<code>void</code>（即JavaScript的<code>undefined</code>）。但兼容模式中，定义或调用零参数的函数会实际使用零参数。例如：激进模式中，<code>a()</code>会被编译成<code>a(undefined)</code>。兼容模式中，<code>a()</code>会被编译成<code>a()</code>。</p>
<p>激进模式中，定义或调用多参数的函数会出错。但兼容模式中，不会出错。</p>
<p>激进模式中，管道操作符把数组单参数分隔为两部分，而兼容模式中管道操作符把所有参数分隔为两部分。</p>
<p>激进模式中，<code>'</code>只能是二元的，而兼容模式中<code>'</code>还可以是一元的。</p>
<p>下文中，为求简便，如果写道“无参数”，也可指激进模式中的参数为<code>void</code>的情形。</p>
<p><code>fast new</code>是指创建类的实例不用加<code>new</code>，编译时会自动加进去，依据类名的首字母大小写，大写的加，小写的不加。但只能识别普通的表示法，像引号内的就不能识别，例如：</p>
<pre><code><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>slow new</code>是指创建类的实例不用加<code>new</code>，编译时也不会自动加进去，而是在运行时自动判断，依据它是不是es6的class或Lemo的类，是的加，不是的不加。因为运行时判断比较慢（尤其是判断是否是es6的class时只能先尝试不加然后看是不是出错，用到了try-catch，更慢），所以谨慎使用。而且它无法照顾到用普通函数写的类。</p>
<p><code>manual new</code>就是传统办法，创建类的实例需要加<code>new</code>。</p>
<p><code>common</code>是指激活<code>exports</code>在某些情况下可简写为<code>\</code>的功能（这属于CommonJS规范）。</p>
<p>编译后的代码是strict mode。</p>
<p>本文的示例是按照兼容模式写的，在激进模式下有些地方需要改写。</p>
<h3>语句</h3>
<p>Lemo代码由语句和注释组成。语句中可以含有子语句。有两种语句：表达式语句和命令语句。类似CoffeeScript，在Lemo中，缩进是很重要的。多个并列语句可以通过分号<code>;</code>合并成1行。类似CoffeeScript，单行还可以通过<code>\</code>拆分成多行。</p>
<p>大多数语句都是表达式语句，但用到这些的是命令语句：</p>
<ul style="font-family: monospace;">
    <li>:（表示赋值时）</li>
    <li>delete</li>
    <li>return</li>
    <li>throw</li>
</ul>
<h3>函数</h3>
<p>函数的声明有2种方式：<code>-&gt;</code>和<code>&lt;&gt;</code>。<code>&lt;&gt;</code>是无参数时的简便方法。参数为1个时括号可省略，这有别于CoffeeScript。</p>
<pre><code><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>如果没有参数，那么必须使用如下一种：</p>
<pre><code><![CDATA[
    a: <> Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>兼容模式允许多参数，但必须要有括号：</p>
<pre><code><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>单参数如果是数组的话，可以使用类似解构赋值的形式：</p>
<pre><code><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p>兼容模式中，<code>@</code>表示JS的<code>arguments</code>。激进模式中，<code>@</code>表示JS的<code>arguments[0]</code>。它是如此简便，在许多情况下，你会喜欢不带参数名。例如，兼容模式中我们可以写：</p>
<pre><code><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>参数可以有默认值：</p>
<pre><code><![CDATA[
    a: (x'ifvoid: 0, y'ifvoid: 0) -> x * y
]]></code></pre>
<p>有默认值的话，参数必须有括号。</p>
<p>如果是<code>'ifvoid</code>默认，则<code>'ifvoid</code>可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (x: 0, y: 0) -> x * y
]]></code></pre>
<p>甚至冒号前面的变量名也可以省略，所以上面的例子也等同于：</p>
<pre><code><![CDATA[
    a: (:0, :0) -> @0 * @1
]]></code></pre>
<p>也等同于：</p>
<pre><code><![CDATA[
    a: ('ifvoid: 0, 'ifvoid: 0) -> @0 * @1
]]></code></pre>
<p>函数的调用有4种表示法：空格、小括号、中括号、大括号。</p>
<pre><code><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5) # only valid in compatible mode
]]></code></pre>
<p>多参数调用一定要加括号，这个CoffeeScript不同。只有单参数调用是可以不加括号的，零参数要加<code>()</code>。</p>
<p>CoffeeScript里面如果函数调用要传递的参数本身也是函数的话，如果它没有参数，那么可写成<code>abc -&gt; Math.random()</code>，但Lemo中绝对不能这么写，否则编译器会误以为这是一个参数为abc的函数。必须采用如下一种：</p>
<pre><code><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>激进模式会不会限制语言的表达力呢？我认为不会，因为我们可以用对象或数组作为参数，就像上面的例子那样，JSON本身已经十分方便了。</p>
<p>兼容模式中，我们还可以使用<code>'</code>来达到类似splat的效果：</p>
<pre><code><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>这两个是不同的：</p>
<pre><code><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>凡是函数都有一个返回值。最后一个语句如果是表达式，那么返回该表达式的值。最后一个语句如果不是表达式，那么返回<code>void</code>。在函数中间也可用<code>return</code>来返回。</p>
<p>不像CoffeeScript，我们没有胖箭头<code>=&gt;</code>。我认为JavaScript使<code>this</code>的含义可自定义是一种错误的设计，它应该始终指向当前对象。我们的函数和CoffeeScript的函数的对应关系如下：</p>
<ul>
    <li>类的方法和构造器（包括嵌套的类的方法和构造器）：CoffeeScript瘦箭头</li>
    <li>类的方法和构造器内部（不包括嵌套的类的方法和构造器，但包括嵌套的类的方法和构造器内部）：CoffeeScript胖箭头</li>
    <li>其余地方：CoffeeScript瘦箭头</li>
</ul>
<h3>赋值与声明</h3>
<p>用<code>:</code>、<code>as</code>。例如：</p>
<pre><code><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b = 4 ? alert "impossible!" # var b; if ((b = 3) === 4) {alert("impossible");}
]]></code></pre>
<p>注意，<code>:</code>不构成表达式，但<code>as</code>构成表达式。例如：</p>
<pre><code><![CDATA[
    abc: <> a: 1
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>void</code>而不是<code>1</code>。但</p>
<pre><code><![CDATA[
    abc: <> 1 as a
]]></code></pre>
<p>执行<code>abc()</code>返回的值是<code>1</code>。</p>
<p>变量不用声明也不能声明，这是因为我们为变量赋值的机制和CoffeeScript相同，如果前面还未出现过则会编译成声明并赋值，如果已出现过则会编译成单纯赋值。</p>
<p><code>:</code>也支持数组解构赋值（不包括嵌套），例如：</p>
<pre><code><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>冒号的作用就是让左边的拥有右边的值。无论是对象中的冒号还是赋值中的冒号，含义相似。</p>
<p><code>:</code>支持对多标识符同时赋值，例如：</p>
<pre><code><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<h3>字符串</h3>
<p>字符串受CoffeeScript启发，不同之处在于不支持单引号、增加了支持原义字符串、不支持简单字符串的多行自动连接。</p>
<p>简单字符串：</p>
<pre><code><![CDATA[
    str: "Welcome to Lemo!"
]]></code></pre>
<p>复杂字符串：</p>
<pre><code><![CDATA[
    htmlStr: """
        <p>
            Welcome to "Lemo"!
        </p>
    """
]]></code></pre>
<p>简单字符串和复杂字符串的区别仅在于复杂字符串中包含双引号字符更容易。</p>
<p>我们不用单引号，因为我觉得你要想用单引号，有两种可能：一种是字符串很长，但这时可以用<code>"""</code>；一种是字符串很短，像<code>'"'</code>，这其实只增加了微小的可读性，我宁愿写成<code>"\""</code>。无论哪一种用单引号都没有明显优势，所以，还是别占用宝贵的符号资源为好。而且双引号是和JSON一致的。</p>
<p>也支持字符串插值，就像CoffeeScript，，不过我们使用<code>\(...)</code>。</p>
<pre><code><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>正则表达式我们用<code>r"..."</code>来表示。例如：</p>
<pre><code><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>正则表达式废除了<code>\</code>的大部分功能，除了一样，就是和普通字符串一样可以用<code>\</code>在行尾连接。在正则表达式中表示双引号字符是用<code>""</code>而不是用<code>\"</code>。正则表达式不支持字符串插值。</p>
<p>这是简单正则表达式。我们还支持复杂正则表达式，例如：</p>
<pre><code><![CDATA[
    str.search(r"""
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    """)
]]></code></pre>
<p>复杂正则表达式的不同点是：空格和换行无意义，支持注释，支持字符串插值，表示双引号字符更简单，表示<code>#</code>需要用<code>\#</code>。字符串插值是用<code>#(...)</code>。</p>
<p>原义字符串是受C#启发，我们使用<code>v"..."</code>来表示。这很适合表示正则表达式，例如：</p>
<pre><code><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>原义字符串完全废除了<code>\</code>的功能，所以行末不能用<code>\</code>来连接。在原义字符串中表示双引号字符是用<code>""</code>而不是用<code>\"</code>。</p>
<p>所以总结一下，凡是字符串起始符号<code>"</code>左边紧接着字母的，可以是表示字符串，也可以表示字符串经转换后的值。</p>
<p>正则表达式引号中间的内容本质上是字符串，这和JS和CoffeeScript都不同。就算是复杂正则表达式中的注释，本质上是属于字符串的，只是转换时去掉了而已。注意，转换是编译时而不是运行时，所以不影响效率。</p>
<p>还有一点和CoffeeScript不同，就是CoffeeScript中：</p>
<pre><code><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
        never mind how long precisely -- having little
        or no money in my purse, and nothing particular
        to interest me on shore, I thought I would sail
        about a little and see the watery part of the
        world..."
]]></code></pre>
<p>这会编译成多行自动连接，连接符是一个空格。但是我们不支持，因为我觉得这只适合西方语言。如果是中文，那加上空格可就错了。所以这个功能不好，应该老老实实用<code>\</code>来连接，是英文的话，前面加个空格。所以，在Lemo中，简单字符串、复杂字符串、原义字符串、正则表达式都是原样呈现多行的。</p>
<h3>数组</h3>
<p>方括号的作用就是表示数组，没有其他用途。</p>
<p>点号的作用就是表示对象的字段。由于数组也是对象，所以JS中<code>arr[3]</code>我们改为<code>arr.3</code>，更一致。其实数组就是属性名为索引值的对象，刚知道时可能会惊讶，但确实是这样，可以用<code>Object.keys(arr)</code>验证这一论断。JS这点和别的语言不同，但不是糟粕，只要形式上变得一致就可以了。</p>
<p>当然，在和带小数点的数字同时出现时，会感觉别扭，这时建议加上括号。比较一下：</p>
<pre><code><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p>数组的表示法和CoffeeScript完全相同。</p>
<h3>对象</h3>
<p>对象的表示法和CoffeeScript基本相同，除了它必须加上大括号，不能省略。</p>
<h3>逻辑运算</h3>
<ul>
    <li>=</li>
    <li>/=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>等号的作用就是判断相等，没有烦人的<code>=</code>、<code>==</code>、<code>===</code>。</p>
<h3>条件</h3>
<p>用<code>if</code>、<code>?</code>、<code>then</code>、<code>else</code>、<code>|</code>。例如：</p>
<pre><code><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
也可以并成一行：
<pre><code><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>或</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>甚至</p>
<pre><code><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code>和<code>then</code>是等价的，<code>|</code>和<code>else</code>是等价的。</p>
<p>条件前置时，<code>if</code>可写可不写，而<code>?</code>（<code>then</code>）则当分行时可写可不写（并成一行时必须写，除非下面是命令语句）。分行的意思是then-block这个区块的第一个字符不在该行内。有的时候为了紧凑，把开头部分留在这一行，那么就要算成是并成一行。</p>
<p>当then-block这个区块的第一个语句是命令语句时，<code>?</code>（<code>then</code>）也可省略（这也适用于模式匹配）。例如：</p>
<pre><code><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>但是要注意，条件前置时无论怎样省略，<code>if</code>和<code>?</code>（<code>then</code>）必须至少出现一个。</p>
<p>条件还可以后置，这时就只能用<code>if</code>，例如：</p>
<pre><code><![CDATA[
    alert("a is true!") if a # if (a) {alert("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p>当条件后置时，<code>if</code>并不作为操作符，整体上并不是个表达式。所以如果有条件后置的语句在函数的末尾，则函数返回的将是void。</p>
<h3>模式匹配</h3>
<p><code>match</code>可以看成是一个增强版<code>switch</code>，它称为模式匹配。例如：</p>
<pre><code><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>上面只是最普通的模式匹配，<code>day</code>是输入，1、2、3……称作模式。它不但比JavaScript的switch强大，甚至比CoffeeScript的switch还强大，看看这个：</p>
<pre><code><![CDATA[
chessBoard: (pos) -> match [pos.x, pos.y]
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>这个称为数组模式。它不是简单地比较两个数组是否相等（那样会始终不相等，因为不是同一个引用），而是检查数组（直接，非嵌套）中每个元素是否相等。当模式以<code>[</code>开头时，适用数组模式。注意一定要直接写出<code>[</code>，绝不能用变量替代，像这样是没用的：</p>
<pre><code><![CDATA[
a: [0, 0]
b: [0, 1]
c: [4, 5]
chessBoard: (pos) -> match [pos.x, pos.y]
    a ? "king"
    b ? "pawn"
    c ? "queen"
    |   "empty"
piece: chessBoard {x: 4, y: 5} # will be "empty"
]]></code></pre>
<p>模式匹配中的“比较”默认是用<code>=</code>，还可以用其他比较运算符，例如：</p>
<pre><code><![CDATA[
message: match statusCode <
    100 ? "unsupported"
    200 ? "informational"
    300 ? "success"
    400 ? "redirect"
    500 ? "client error"
    600 ? "server error"
    |     "unsupported"
]]></code></pre>
<p><code>|</code>可以跟前面的并在一起，此时用<code>or |</code>或<code>or else</code>，但该项不能有<code>then</code>或<code>?</code>，所以上面的例子可以写成：</p>
<pre><code><![CDATA[
message: match statusCode <
    100 or | "unsupported"
    200    ? "informational"
    300    ? "success"
    400    ? "redirect"
    500    ? "client error"
    600    ? "server error"
]]></code></pre>
<p>用这种方法的时候<code>or</code>可以省略，所以还可以写成：</p>
<pre><code><![CDATA[
message: match statusCode <
    100 | "unsupported"
    200 ? "informational"
    300 ? "success"
    400 ? "redirect"
    500 ? "client error"
    600 ? "server error"
]]></code></pre>
<p>不但可以用比较运算符，还可以自定义比较函数，例如：</p>
<pre><code><![CDATA[
text: "This is a dog."
speak: match <> text.includes(@)
    "cat" ? "meow"
    "dog" ? "woof"
    |       "unknown"
# speak is "woof"
]]></code></pre>
<p>当<code>match</code>后紧接的是函数时，则被识别成自定义比较函数。要直接写出<code>-&gt;</code>或<code>&lt;&gt;</code>，绝不能用变量替代，这一点和数组模式相似。</p>
<p>还有or模式和and模式。or模式我们会经常用到，例如：</p>
<pre><code><![CDATA[
day: "Tue"
action: match day
    "Sat" or "Sun" ? "have a rest"
    |                "work"
]]></code></pre>
<p>and模式则不常用，但也有例子：</p>
<pre><code><![CDATA[
array: ["a", "c", "b", "d"]
message: match <> array.includes(@)
    "a" and "b" and "c" ? "The array includes all of the first 3 letters."
    "a"                 ? "The array includes a."
    "b"                 ? "The array includes b."
    "c"                 ? "The array includes c."
    |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>由此可知，or和and作为运算符在模式中使用是有限制的，它作为运算符时必须出现在括号内，否则会被认为是模式。所以真的有这个需求的话，要用个括号包起来。不过这两个运算符出现在模式中好像也没有什么用。</p>
<p>作为模式使用时要么全是<code>or</code>，要么全是<code>and</code>，两个不能在一个模式中一起出现，否则编译器会无法判断。括号内的无此限制。</p>
<p>注意<code>or |</code>是一种特殊的写法，并不属于or模式，所以<code>or |</code>可以和<code>and</code>在一个模式中一起出现。</p>
<h3>循环</h3>
<p>循环其实并不符合函数式编程的理念，我们没有循环。但提供了内置函数repeat来模拟循环。为方便起见，本文中的“循环”一般指repeat。例子：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>迭代器返回<code>false</code>则表示跳出循环，相当于JS的<code>break</code>：</p>
<pre><code><![CDATA[
    repeat[10, i ->
        if i > 5 then return false
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>不设次数则表示永远，相当于JS的<code>while (true)</code>：</p>
<pre><code><![CDATA[
    repeat ->
        if abc() then return false
        doSomething()
]]></code></pre>
<h3>类</h3>
<p>和类有关的关键字有<code>class</code>、<code>super</code>、<code>static</code>、<code>new</code>、<code>me</code>、<code>Me</code>。例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me.name: @0

        move: meters ->
            alert me.name + " moved \(meters)m."

    Snake: class Animal
        move: <>
            alert "Slithering..."
            super 5

    Horse: class Animal
        move: <>
            alert "Galloping..."
            super 45

    sam: Snake "Sammy the Python"
    tom: Horse "Tommy the Palomino"

    sam.move()
    tom.move()
]]></code></pre>
<p>JS和CoffeeScript的extends纯属多余，我们使用更美丽的办法：直接在class后写出你要继承的类，使用表达式而非语句，类名用赋值来设定。</p>
<p>类的声明方式比较像CoffeeScript。但我们的更严格。我们多了getter and setter功能，以及<code>constructor:</code>简写成<code>new:</code>。在Lemo中，类的所有声明的子项都必须是以冒号的形式。</p>
<p>JS的<code>this</code>我们用<code>me</code>代替。我们还有一个关键字<code>Me</code>，M大写，表示<code>me</code>所在的类。当静态调用时<code>Me</code>和<code>me</code>相同，但建议使用<code>Me</code>，因为大写比较像类。</p>
<p>getter和setter的例子：</p>
<pre><code><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p><code>'get</code>和<code>'set</code>一看就明白。这里的亮点是<code>me._name</code>，它编译成的JS不是像你猜测的那样是<code>this._name</code>，而是<code>this[_name]</code>，其中<code>_name</code>是Symbol。编译器一碰到<code>me.</code>，并且后面是以<code>_</code>开头的话，即这样编译。</p>
<p>这被称作“防冲突字段”，可以把它近似看成是私有字段。防冲突字段的好处不是外部无法访问，外部虽然无法通过对象的属性直接访问，但可以间接访问，最大的好处是继承类可以放心地使用同名的防冲突字段，而不用担心会覆盖，这在类关系很复杂的大型项目中尤其重要。因为这些字段不属于API，通常别的开发者是不会告诉你是怎样用的，如果你继承别人写的类，有可能你的私有字段正好重名，类的行为就被破坏了。</p>
<p>以<code>_</code>开头的字段名还可以出现在字段的声明中，例如：</p>
<pre><code><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>字段的声明中只要是以<code>_</code>开头的，便自动成为防冲突字段。</p>
<p>创建实例时无需使用new，因为其实JS的new是多余的，如果一个函数只能被当作类来使用，肯定会加new。所以在Lemo中，只要这被识别为一个类，那么当被作为函数调用时，编译出来的就会自动加上new。反之，如果不是类，编译出来的就不会加上new。具体的识别方法由头行指定。当然，罕见的情况下，某个库的函数名可能会不符合约定，造成被识别为类，这时可以用<code>nonew</code>关键字，语法上和<code>new</code>一样。</p>
<p><code>Number</code>、<code>String</code>、<code>Boolean</code>始终被识别为不是类，无论编译选项如何。</p>
<p>CoffeeScript对于静态类是使用<code>@property: value</code>，我们使用的是<code>static</code>关键字，即<code>static property: value</code>。</p>
<p>防冲突字段也适用于静态类，区别是使用的不是<code>me.</code>而是<code>Me.</code>。</p>
<p>有的时候我们想写静态构造函数，也可以，<code>static</code>后面不要跟任何名称即可，例如：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result[0]
            Me.part2: result[1]
]]></code></pre>
<p>不要在类的方法或构造器内部为另一个对象的原型方法赋值。例如这样不合理（虽然不会出错）：</p>
<pre><code><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>这是因为在该原型方法内使用<code>me</code>的话表示不了你想要表示的东西。正确的方法是把它写在类的外面。至于嵌套类，是可以的，因为编译器能识别<code>class</code>关键字，从而做出对于<code>me</code>的正确解释。不过嵌套类好像用处也不大，建议类与类的关系还是扁平为好。</p>
<p>只要类有实例化需求，就要避免取非大写开头的名称，否则会影响编译器判断。如果类的所有需求都是静态，那么就任意了。</p>
<h3>上下文</h3>
<p>JavaScript表示上下文的只有this和arguments，我们有6个，分别是：</p>
<ul>
    <li>当前对象：<code>me</code></li>
    <li>当前对象的类：<code>Me</code></li>
    <li>闭包中的当前函数：<code>fun</code></li>
    <li>当前参数：<code>@</code></li>
    <li>赋值中冒号左边的标识符的旧值：<code>self</code></li>
    <li>当前模块的exports：<code>\</code></li>
</ul>
<p><code>@</code>、<code>\</code>后面的点号可以省略，除非点号后面跟<code>(</code>或<code>"</code>或<code>v"</code>。</p>
<h3>异常</h3>
<p>用<code>try</code>、<code>catch</code>、<code>finally</code>、<code>throw</code>，具体实现和CoffeeScript完全相同。例如：</p>
<pre><code><![CDATA[
    try
        allHellBreaksLoose()
        catsAndDogsLivingTogether()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<h3>管道</h3>
<p>管道操作符是<code>|></code>。例子：</p>
<pre><code><![CDATA[
    u = require("underscore")
    [3, 4, 5] |> u.map x -> x * 2 |> u.max
]]></code></pre>
<p>管道使我们使用underscore函数库可以一种人类习惯的顺序来书写，我们再也不用这样写了：</p>
<pre><code><![CDATA[
    u = require("underscore")
    u.max(u.map([3, 4, 5], x -> x * 2))
]]></code></pre>
<p>还有一种运算符<code>::</code>，称之为“胖点”，专门应用于含有管道运算符的表达式，如果你想让管道和点号混合，胖点能提供更强的可读性。例如：</p>
<pre><code><![CDATA[
    [3, 4, 5] |> u.map x -> x * 2 :: map x -> x + 1 |> u.max
]]></code></pre>
<p>相当于：</p>
<pre><code><![CDATA[
    (([3, 4, 5] |> u.map x -> x * 2).map x -> x + 1) |> u.max
]]></code></pre>
<p>所以胖点基本就是点号，只不过它的优先级比较低，和管道运算符相同。而且看起来比较“胖”，和管道运算符比较接近，所以比较舒服。</p>
<h3>异步</h3>
<p><code>'wait</code>类似C#的await，使异步看上去像同步一样（然而不改变其异步的本质），所以它超越了promise。考虑这样一个JS：</p>
<pre><code><![CDATA[
    abc().then(function(x){
        return x.def();
    })
    .then(function(x){
        return x.ghi();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>我们现在可以写成：</p>
<pre><code><![CDATA[
    console.log abc()'wait.def()'wait.ghi()'wait
]]></code></pre>
<p>一旦代码有<code>'wait</code>，那么代码所在的函数（直接所在，非嵌套）就被编译成异步函数。我们不用async关键字声明异步函数，这个关键字根本多余。</p>
<p><code>'wait</code>针对的要么是promise，要么是别的异步函数的返回值。异步函数的返回值是被编译成一种特殊的生成器对象，我们将其称为任务。注意，生成器对象不是生成器函数。</p>
<p>在异步函数内部，每执行到<code>'wait</code>，会进入等待，直到该promise或任务有了结果，才继续往下执行。</p>
<p>网上已有文章介绍如何用yield来实现异步，那我们为什么不直接用yield，要发明一个新的符号？因为：</p>
<ul>
    <li>yield的本来意思是“产出”，用来表示异步显得怪怪的。</li>
    <li>yield是前置的，但这里其实应该后置。试想，前面的例子翻译成yield会是什么样？<code>var result = yield (yield (yield abc()).def()).ghi();</code>多层括号，前面3个yield，多难看？而且从时间顺序来说也应该后置。其实C#的await也应该是后置，它也弄得不好。是什么时候wait？是promise函数或异步函数执行完后wait，而不是wait之后再执行。注意promise函数执行完不表示promise有了结果，promise函数本身的执行是同步的。</li>
</ul>
<p>异步和管道结合的例子：</p>
<pre><code><![CDATA[
    x: data |> lib.process1'wait |> lib.process2'wait
    y: data |> lib.remoteCombine(anotherData1)'wait |> lib.remoteCombine(anotherData2)'wait
    console.log(x, y)
]]></code></pre>
<p>调用异步函数也可以不加<code>'wait</code>，当调用方不需要等待promise或任务出结果的时候。</p>
<p>用<code>'wait</code>调用异步函数的例子：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
    task()'wait
    console.log "success"
]]></code></pre>
<p>不用<code>'wait</code>，也可以调用异步函数并达到相同的目的：</p>
<pre><code><![CDATA[
    task: <>
        aaa()'wait
        bbb()'wait
        console.log "success"
    task()
]]></code></pre>
<p>注意，不用<code>'wait</code>调用异步函数的时候，异步函数执行到第一个<code>'wait</code>的位置之前返回调用方。下面的例子说明了先后顺序：</p>
<pre><code><![CDATA[
    task: <>
        console.log "stage 1"
        aaa()'wait
        console.log "stage 3"
        bbb()'wait
        console.log "stage 4"
    task()
    console.log "stage 2"
]]></code></pre>
<p>其实用<code>'wait</code>调用异步函数的时候也是异步函数执行到第一个<code>'wait</code>的位置之前返回调用方，只不过调用方也在等待，看起来就像没有返回一样。</p>
<p>异步和<code>do</code>结合的例子：</p>
<pre><code><![CDATA[
    largeTask: <>
        do'wait <>
            aaa()'wait
            bbb()'wait
        do'wait <>
            ccc()'wait
            ddd()'wait
        do'wait <>
            eee()'wait
            fff()'wait
]]></code></pre>
<h3>存在</h3>
<p>这几个关键字或操作符和“存在性”有关<code>'void</code>、<code>'null</code>、<code>'ok</code>、<code>'ifvoid</code>、<code>'ifnull</code>。</p>
<p>首先我们经常碰到这样的要求：要检查某个变量名是否是已定义，但又不能引发异常。JS中只能用<code>typeof a === "undefined"</code>。在Lemo中我们可以用更紧凑的<code>a'void</code>。</p>
<p><code>a'null</code>，就相当于<code>typeof a === "object" &amp;&amp; a === null</code>，也不会引发异常。如果直接写<code>a = null</code>的话是有点问题的，如果它既不是null又没定义，就会引发异常。</p>
<p><code>a'ok</code>，意思就是a既不是void，也不是null。</p>
<p><code>'ok</code>还可以和点号结合起来使用，<code>'ok.</code>等同于CoffeeScript的<code>?.</code>，例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.winner?.address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip = lottery.winner'ok.address'ok.zipcode
]]></code></pre>
<p><code>'ok</code>还可以和函数调用结合起来使用，和CoffeeScript的<code>?(...)</code>一样。例如这段CoffeeScript</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner?().address?.zipcode
]]></code></pre>
<p>就可以写成：</p>
<pre><code><![CDATA[
    zip = lottery.drawWinner'ok().address'ok.zipcode
]]></code></pre>
<p><code>'ifnull</code>和<code>'ifvoid</code>必须后面跟冒号。例如：</p>
<pre><code><![CDATA[
    a'ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a'ifvoid: 8 # if (a === undefined) {a = 8;}
]]></code></pre>
<h3>'</h3>
<p><code>'</code>的形式有两种，一种是一元<code>'</code>，一种是二元<code>'</code>。一元<code>'</code>即函数的单参数变体，兼容模式专用。其他的都是二元<code>'</code>。</p>
<p>编译器如何判断某个<code>'</code>是一元还是二元？看<code>'</code>后面紧跟的字符。如果是数字或字母，则是二元，否则（例如是符号、空格或根本没有字符）要么是一元，要么无法解析。</p>
<p>所以这两者是一样的：</p>
<pre><code><![CDATA[
    a'void
    a 'void
]]></code></pre>
<p>但这个不一样：</p>
<pre><code><![CDATA[
    a' void
]]></code></pre>
<p>为了可读性，一元的<code>'</code>前面的那个字符不能是空白。像这个就是非法的，必须无法解析：</p>
<pre><code><![CDATA[
    a ' void
]]></code></pre>
<p>有些情况下二元<code>'</code>的第一个算元可以省略，例如函数参数默认值中的变量名，但是它仍然属于二元。</p>
<h3>in</h3>
<p><code>in</code>的用法和CoffeeScript几乎完全相同，当然，如果要表示否定，可以用<code>not in</code>，不能用<code>!in</code>。</p>
<h3>is</h3>
<p><code>is</code>表示左边是右边的类型，类似于JavaScript的<code>instanceof</code>，但又有些区别，它还能判断原始类型，可以说结合了<code>instanceof</code>和<code>typeof</code>。当右边是<code>Number</code>、<code>Boolean</code>、<code>String</code>（必须严格表示为这3个之中的1个，不能是引用）时使用<code>typeof</code>。</p>
<pre><code><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>与<code>in</code>相似，<code>is</code>表示否定时也是可以用<code>not is</code>，不过也可以使用更顺眼的<code>isnt</code>，但切记，绝不能用<code>is not</code>。</p>
<h3>delete</h3>
<p><code>delete</code>和JavaScript中的稍有不同。它不再是一个表达式。这是因为在JavaScript strict mode中并没有值为false的情况，而是抛出异常。既然我们都是用strict mode，所以没必要弄成表达式。</p>
<h3>rem和mod</h3>
<p><code>rem</code>即是JavaScript的<code>%</code>。<code>mod</code>是另一种求余，正负号和除数相同，只要除数是正数，结果就不为负，所以这种求余适用范围可能更广一些。<code>a mod b</code>相当于JavaScript的<code>(a % b + b) % b</code>。</p>
<h3>do</h3>
<p><code>do</code>关键字的用法和CoffeeScript完全相同。</p>
<h3>注释</h3>
<p>使用<code>#</code>和<code>###</code>，和CoffeeScript完全一样。</p>
<h3>插入JavaScript</h3>
<p>使用<code>`</code>。例如：</p>
<pre><code><![CDATA[
    hi = `function() {
        return [document.title, "Hello JavaScript"].join(": ");
    }`
]]></code></pre>
<h3>&lt;&lt;和&gt;&gt;</h3>
<p>通常来说，把一行拆成几行会增加可读性。但有的时候恰恰相反，你会发觉把几行特别短小的代码合并成一行反而更好看，特别是当你有很多这样的“几行”的时候。例如：</p>
<pre><code><![CDATA[
    A: class <<aaa: 1>>
    B: class <<bbb: 1>>
    C: class <<ccc: 1>>
    D: class <<ddd: 1>>
    E: class <<eee: 1>>
]]></code></pre>
<p>和这个做对比：</p>
<pre><code><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>这时<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的威力就体现出来了。<code>&lt;&lt;</code>表示接下去的代码缩进一级，<code>&gt;&gt;</code>表示还原。</p>
<p><code>&lt;&lt;</code>和<code>&gt;&gt;</code>必须在1行内结束。也就是说，只能把多行合并成1行，无法把多行合并成2行（相信这个需求根本没有）。</p>
<p>这两个符号和分号结合使用很方便，各司其职，分号用来合并并列的语句，这两个符号用来合并有层级的语句。</p>
<h2>关键字</h2>
<p>关键字不能作为变量名。</p>
<ul style="font-family: monospace;">
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>rem</li>
    <li>return</li>
    <li>self</li>
    <li>static</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>保留字</h2>
<ul style="font-family: monospace;">
    <li>con</li>
    <li>elif</li>
    <li>export</li>
    <li>import</li>
</ul>
<h2>内置函数</h2>
<ul style="font-family: monospace;">
    <li>repeat</li>
</ul>
<h2>符号</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>"""</li>
    <li>v"</li>
    <li>`</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'void</li>
    <li>'null</li>
    <li>'ok</li>
    <li>'ifvoid</li>
    <li>'ifnull</li>
    <li>'get</li>
    <li>'set</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
</ul>
<h2>运算符优先级</h2>
<p>运算符必须至少有一个算元（凡是算元都是表达式），并且运算结果是表达式。不过也不是所有运算符都有优先级。算元必须占满该行剩余部分（除非用<code>&lt;&lt;</code>和<code>&gt;&gt;</code>）的运算符（即通常分多行写的）就没有优先级，例如<code>match</code>和<code>class</code>。下面表格中，a、b、c表示算元，x、y、z表示其他组成部分。</p>
<table>
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="4">13 left-to-right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>12 left-to-right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>11 left-to-right</td>
        <td>Function Call</td>
        <td><code>a(b)</code></td>
    </tr>
    <tr>
        <td rowspan="3">10 right-to-left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td>9 right-to-left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="4">8 left-to-right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td rowspan="2">7 left-to-right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">6 left-to-right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="6">5 left-to-right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td>4 left-to-right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>3 left-to-right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td rowspan="2">2 right-to-left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>1 right-to-left</td>
        <td>Conditional</td>
        <td><code>if a then b else c<br/>a ? b | c</code></td>
    </tr>
    <tr>
        <td rowspan="2">0 left-to-right</td>
        <td>Pipe</td>
        <td><code>a |&gt; x</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
</table>
<h2>例子</h2>
<pre><code><![CDATA[
    # Assignment:
    number:   42
    opposite: true

    # Conditions:
    number: -42 if opposite

    # Functions:
    square: <> @ * @

    # Arrays:
    list: [1, 2, 3, 4, 5]

    # Objects:
    math: {
        root:   Math.sqrt
        square: square
        cube:   <> @ * square @
    }

    # Existence:
    alert "I knew it!" if elvis exists

    # Array comprehensions:
    cubes: list.map <> math.cube @
]]></code></pre>
<h2>常见问题</h2>
<p>问：为啥没有正则表达式符号？</p>
<p>答：正则表达式完全可以用<code>r"</code>来表示。</p>
<p>问：为啥没有位操作符？</p>
<p>答：首先，Lemo作为高级语言，没必要支持。其次，JavaScript的位操作是专门针对32位数字的，这本身就不合理。</p>
<p>问：为啥没有生成器？</p>
<p>答：生成器是适合特定用途的，似乎普适性还不够。至于缩短代码长度？加一个类库也可以达到这个目的，干嘛非得改动语言层面呢？至于在异步操作中的用途，Lemo也已经有了更好的替代方法。</p>
<p>问：为啥没有“原义复杂字符串”？</p>
<p>答：乍看之下似乎应该可以有，但是考虑这个：</p>
<pre><code><![CDATA[
    v"""C:\Windows"""
]]></code></pre>
<p>这就有歧义了，到底是看成“原义复杂字符串”呢，还是看成原义字符串内开头是一个双引号（因为原义字符串的双引号是用两个双引号表示的）？</p>
<p>问：为啥函数除了箭头符号以外还要弄个菱形符号？</p>
<p>答：我的目标是消除CoffeeScript中参数两边的括号。但是如果没有括号的话会产生歧义。所以我就想出了这个办法，如果不加括号，那就必须为1个参数。那零个参数怎么办？就再造一个符号呗。至于多个参数，就必须加括号，不过多参数并不在我的理想化（即激进模式）的构想当中，所以这也可以接受。再有一个原因，就是CoffeeScript用箭头表示零参数的话看上去既别扭又误导，箭头嘛，感觉应该左右都有东西才对。</p>
<p>问：既然如此，那为啥激进模式不废除箭头符号？反正有<code>@</code>可以用。</p>
<p>答：激进模式中，大多数情况下确实没必要给参数取名，但当你有多层函数，内层调用外层参数的时候，取名就有必要了。</p>
<p>问：为啥保留字那么少？</p>
<p>答：很多语言都有很多保留字，但我觉得你设计语言的时候预先定义好未来的功能，那未来有可能是你没料到的。我们在头行使用版本号，也达到了“安全”的目的，因为可以保证只要你不修改版本号，就不会出现兼容性问题。</p>
<p>问：不支持<code>var</code>是受CoffeeScript启发，但为啥不支持ES6的<code>let</code>和<code>const</code>？</p>
<p>答：我的理念是，一名程序员也许不熟悉正在开发的文件之外的其他文件，但是一般都会熟悉这个文件当中的其他区域。<code>let</code>提供块级的保护，但是只要你熟悉的不是只是这个块，你完全可以使用一个不同的变量名。块级保护太小了，函数级保护已经足够坚固。否则的话语言本身的复杂度也会增加。<code>let</code>和CoffeeScript风格之间也有矛盾。至于<code>const</code>，我觉得理念有问题，<code>const</code>只是针对常量而已，而我们让某个东西不可变，不是防自己改，是防别人改。通常是自己做了个库，别人使用时，在运行时可能会乱改内部逻辑。变量仅自己可见，别人改不了，又何必成为常量？真正要保护的其实是对象的属性或方法，这个<code>const</code>无法做到。可以通过<code>Object.defineProperty</code>来做到。但要动就得动包括原生对象在内的所有的对象，让方法都变得坚固（即变成类似静态语言的样子），这工作量太大了，可行性也值得怀疑，所以目前暂不做。</p>
<p>问：为何不支持对象解构赋值和复杂数组的解构赋值？</p>
<p>答：对象解构赋值过于复杂。它符合了人类一部分直觉，但违反了人类另一部分直觉，导致一开始根本就看不懂。复杂数组的解构赋值是中等复杂，以后也许会支持。至于对象解构赋值，以后即使支持，语法也要改得更自然。</p>
<p>问：为什么arguments用<code>@</code>表示？</p>
<p>答：首先，<code>@</code>形状也像个a。其次，<code>@</code>是符号中看上去最不像符号的，我们经常会使用孤立的<code>@</code>作为一个表达式，这时如果用其他符号，会显得不像个表达式，就不舒服了。</p>
<p>问：为什么以多参数调用函数一定要加括号？CoffeeScript不是可以不加吗？</p>
<p>答：多参数要用到逗号，不加括号的话，逗号到底分隔什么，不容易看清楚，大多数时候违反人类直觉。而且因为我觉得激进模式更完美，如果多参数可以不加括号，就有些鼓励人们采用兼容模式了。</p>
<p>问：<code>@</code>很好用，如果catch的上下文也能用一个符号表示就好了。</p>
<p>答：本来我考虑再用个新的符号来指代子语句内的上下文，不仅限于catch，但想想，不宜。用<code>@</code>时你很容易看清某个<code>@</code>所对应的是哪个函数，因为函数符号很好辨认。但子语句仅有的特征是缩进，而缩进我们是用得非常多的，很容易这个新符号的意思会变来变去，导致你搞混。如果这个新符号仅限于catch，又适用面太小。</p>
</body>
</html>
