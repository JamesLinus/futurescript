<!DOCTYPE html>
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!-- version -->
    <title>FutureScript 0.6.0</title>
    <link rel="stylesheet" href="base.css" type="text/css" />
    <style type="text/css"><![CDATA[
        html {
            font-size: 13pt;
        }
        body {
            width: 900px;
        }
        table.table {
            border-collapse: collapse;
        }
        table.table, table.table td, table.table th {
            border: 1px solid black;
        }
        td, th {
            vertical-align: top;
            text-align: left;
        }
        code {
            font-size: 0.9rem;
        }
        p > code, li > code {
            background-color: rgb(224,224,224);
            padding-left: 0.2em;
            padding-right: 0.2em;
        }
        pre {
            border-left: 0.6em solid rgb(224,224,224);
            padding: 0.25em 1em;
        }
        .warning {
            background-color: rgb(255,192,192);
        }
        .detail {
            font-family: STKaiti, KaiTi;
            font-size: 0.85rem;
            color: rgb(144,144,144);
        }
        .question {
            text-decoration: underline;
        }
        .try {
            display: none;
        }
    ]]></style>
    <script src="doc-html.js" type="text/javascript" />
</head>
<body>
<!-- version -->
<pre class="try"><code class="fus"><![CDATA[
    fus 0.6.0
    import "./manifest" all

    q: encodeURIComponent("select * from yahoo.finance.quotes where symbol in (\"AAPL\")")
    env: encodeURIComponent("store://datatables.org/alltableswithkeys")
    query: "?q=\(q)&env=\(env)&format=json"

    # Asynchronous function
    do --
        console.log "Querying stock price..."

        response: web.jsonGet("https://query.yahooapis.com/v1/public/yql\(query)")'wait
        quote: response.body.query.results.quote

        console.log "Apple Inc. Bid Price: \(quote.Bid), Ask Price: \(quote.Ask)"

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 0.6.0

    u: import "underscore"
    _: import "lodash"

    # Pipe operator |> makes using underscore and lodash easier than ever.
    # Forget _() and value().
    console.log [2, 3, 4] |> _.max

    # You can even use different libraries in one chain, or mix native methods
    # such as "map". Still so simple.
    console.log [1, 1, 3, 3, 5, 7] |> u.shuffle :: map(x -> -x) |> _.uniq

]]></code></pre>
<pre class="try"><code class="fus"><![CDATA[
    fus 0.6.0

    # Pattern matching could be regarded as an enhanced "switch", except that
    # it's an expression rather than a command so it's functional.
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    console.log text

]]></code></pre>
<h1>Introduction</h1>
<p>When I was writing JavaScript code I often think: <code>==</code> and <code>===</code> are very annoying, and if it could be <code>=</code> then that would be great. Later I found that if a new language used the colon <code>:</code> to assign, this dream could have come true. Because the colon in JSON means "to let the left-hand side have the value of the right-hand side", the meaning is similar. We just need to extend this grammar to "variable assignment".</p>
<p>I also thought, that if all types of member access uniformly use <code>.</code>, isn't that perfect? Regardless of whether it's object member, array member, or the object member name is enclosed with quotation marks. This means <code>a[0]</code> in JS could be written as:</p>
<pre><code class="fus-part"><![CDATA[
    a.0
]]></code></pre>
<p>And <code>a["prop name"]</code> in JS could be written as:</p>
<pre><code class="fus-part"><![CDATA[
    a."prop name"
]]></code></pre>
<p>Many famous JS programmers say that function should just take a few arguments. If there are many arguments, that means the function isn't designed well. I fully agree, but with some more radical thought: Does the "multiple arguments" grammar by itself make things complicated?</p>
<p>I also thought, that in today's world all languages has version problems. This not only makes developers afraid to upgrade language versions for the possible incompatibility, but also make the language designers fear to make big changes, so that new features are getting fewer and fewer. Can we think a wholly new mechanism to solve that problem?</p>
<p>Then an idea of designing a new language came into my mind.</p>
<p>The first feeling of FutureScript is that the grammar is extremely consistent:</p>
<ul>
    <li>Bracket pair <code>[</code> and <code>]</code> always means array literal. Brace pair <code>{</code> and <code>}</code> always means object literal.</li>
    <li>Member access always uses the dot <code>.</code>, be it an object member or an array member, or the object member name is enclosed with quotation marks or not.</li>
    <li>If it's "let left-hand side have the value of right-hand side", always use <code>:</code>, be it in object literal or assignment.</li>
    <li>No annoying <code>==</code> and <code>===</code>. The equal character <code>=</code> means equal.</li>
</ul>
<pre><code class="fus-part"><![CDATA[
    a: ["hello", "world"] # var a = ["hello", "world"]
    console.log(a.0, a.1) # console.log(a[0], a[1])

    b: 5
    a.(b): "last" # a[b] = "last"

    c: {scheme: "http"} # var c = {scheme: "http"}
    c.scheme: "https"
    c."content-length": 123 # c["content-length"] = 123
]]></code></pre>
<p>The second feeling of FutureScript is that it's extremely readable. See this:</p>
<pre><code class="fus-part"><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
]]></code></pre>
<p>CoffeeScript can also achieve this by <code>a ?= 8</code>, but FutureScript is more readable. Also for logical operators, we dropped JS's equivalents in favor of the more natural <code>and</code>, <code>or</code>, <code>not</code>.</p>
<p>The third feeling of FutureScript is that it can extremely simplify your code. All JS programmers know how unnatural the asynchronous grammar is. But now we can:</p>
<pre><code class="fus-part"><![CDATA[
    console.log aaa()'wait.bbb()'wait.ccc()'wait
]]></code></pre>
<p>You know, "promise" is a leap forward than the traditional "triangle of doom". But the code above is a further leap forward. It's equal to the following promise：</p>
<pre><code class="js"><![CDATA[
    aaa().then(function(x){
        return x.bbb();
    })
    .then(function(x){
        return x.ccc();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>In FutureScript, there's no keyword of more than 7 letters. Such as：</p>
<ul>
    <li><code>undefined</code>, superseded by <code>void</code>.</li>
    <li><code>arguments</code>, superseded by <code>@</code>. <code>@0</code> means <code>arguments[0]</code>. In the middle of the "@" character is an "a". Easy to remember. (Let's agree that <code>@</code> is pronounced /ɑːg/.)</li>
    <li><code>instanceof</code>, superseded by <code>is</code>.</li>
</ul>
<p>We require that in every file you must mark the FutureScript version number in the top line. I believe this will solve the version problem that exists in JS and CoffeeScript, because any version of FutureScript contains compilers of all historical versions. This means 2.0.0 contains 1.0.0.</p>
<p>To read FutureScript code, very few additional things need to be remembered (just 4 things):</p>
<ul>
    <li><code>#</code> means comment.</li>
    <li><code>a(b)</code> in JS could be simplified as <code>a b</code>。</li>
    <li><code>-&gt;</code>, <code>&lt;&gt;</code> and <code>--</code> all mean function. The arrow one takes parameters while the other two take no parameter (detailed difference will be discussed later).</li>
    <li><code>**</code> means exponentiation. So <code>2 ** 3</code> is 8.</li>
</ul>
<p>Okay, basically if you have finished reading this chapter, you can read any FutureScript code (at least guess it).</p>
<p>An example is provided at the last of this chapter:</p>
<!-- version -->
<pre><code class="fus"><![CDATA[
    fus 0.6.0

    number:   36
    opposite: true

    # number will be -36
    number: -self if opposite

    square: x -> x ** 2

    list: [1, 2, 3, 4, 5]

    # squares will be [1, 4, 9, 16, 25]
    squares: list.map(x -> square x)
]]></code></pre>
<p>If you want to not only read but also write FutureScript, then please read the remaining chapters. Below are tutorial (shown in normal font), and detailed specification that may be uninteresting to developers (shown in gray, smaller font). On first time reading, you can just read the tutorial (tutorial is also part of the specification, though easier to understand).</p>
<h1>Usage</h1>
<p>(This chapter is not part of the language specification. Because tools will be updated in the future, this chapter may be out-of-date then.)</p>
<h3>Install</h3>
<p>First confirm you've installed Node.js 5.0 or higher on your computer.</p>
<pre><code><![CDATA[
    npm install -g futurescript
]]></code></pre>
<p>For detailed usage of <code>fus</code> command, please click:</p>
<p><a href="https://www.npmjs.com/package/futurescript">https://www.npmjs.com/package/futurescript</a></p>
<h3>Text Editor</h3>
<p>We provide syntax highlighting modules for text editors such as Sublime Text and Atom. I think it should also work on WebStorm and other editors that support tmbundle.</p>
<p><a href="tmbundle.zip">Click here to download</a>.</p>
<p>Extract it to a directory. Name the directory as <code>FutureScript</code>.</p>
<p>Regarding Sublime Text, in its menu choose Preferences, Browse Packages. The popped-up window is the directory containing all language packages. Copy FutureScript directory into it.</p>
<p>The syntax highlighting name we use is "FutureScript h1".</p>
<h1>Code Structure</h1>
<h2>File Format and Appearance</h2>
<p>File extension is <code>.fus</code>.</p>
<p class="detail">Fus file appearance: comprises version line, statements, comments, and meaningless whitespaces. Statements can be nested. Version line and statements are meaningful. Comments and meaningless whitespaces are meaningless.</p>
<p class="detail">A statement is not an expression nor treated as expression. An expression is not a statement, but can be treated as statement (named as "expression statement"). There are 2 kinds of statements: expression statements and command statements.</p>
<p>Similar to CoffeeScript, in FutureScript, indents are important, for they form the nested structure. Indent can be substituted by <code>&lt;&lt;</code> and <code>&gt;&gt;</code>.</p>
<p>Similar to CoffeeScript, juxtaposed lines can be combined using semicolon<code>;</code>, and a single line can be splitted by using <code>\</code>.</p>
<p class="detail">Empty line, or blank line, means a line that doesn't have any character.</p>
<p class="detail">Whitespace line, means an empty line or a line that only have whitespaces.</p>
<p class="detail">Meaningless whitespace, means an empty line, or the whitespace that's meaningless in the right side of a line.</p>
<p class="detail">In all text hereinafter, we assume that meaningless whitespaces are removed.</p>
<p class="detail">Most statements are expression statements, except that these are command statements:</p>
<ul class="detail">
    <li>: (colon, when meaning assignment)</li>
    <li>delete</li>
    <li>import (excluding <code>import</code> expression)</li>
    <li>export (limited to <code>export</code> at the start of a statement, so excluding<code>export as</code>, but including<code>export...as</code>)</li>
    <li>throw</li>
    <li>pause</li>
</ul>
<p class="detail">Given a statement, the maximum consecutive content of the level of the statement is called the block of the statement. Block doesn't include version line. Besides block, there is list. Either block or list is called a "container". Block's child can be statement or comment. List's child can't be statement. A child block (or child list) of a statement means the first-level descendant of the statement. A child statement of a block also means first-level descendant.</p>
<p class="detail">These containers and blocks:</p>
<ul class="detail">
    <li>Root block</li>
    <li>Function block</li>
    <li><code>then</code> block</li>
    <li><code>else</code> block</li>
    <li><code>try</code> block</li>
    <li><code>catch</code> block</li>
    <li><code>finally</code> block</li>
</ul>
<p class="detail">All other containers are lists. For example:</p>
<ul class="detail">
    <li><code>class</code> list</li>
    <li>Array list</li>
    <li>Object list</li>
    <li><code>match</code> list</li>
</ul>
<p>If a block (except <code>catch</code> block) has only a single statement, it can be written in the same line without indent. This is called inline block. For example:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 then aaa()
]]></code></pre>
<p class="detail">Note that <code>aaa()</code> still belongs to <code>then</code> block. Also note, that in this notation, there must be a corresponding keyword or symbol ahead of the block. In the above example the <code>then</code> can't be omitted. From this we know that every block (except that in post-if) has a leading keyword or symbol in grammar. For example, <code>-&gt;</code>, <code>then</code>, and<code>try</code>. It can be omitted only when it isn't at the start of a statement and isn't at the start of a line and isn't followed by an inline block (also depends on whether the grammar supports it. For example <code>-&gt;</code> can't be omitted).</p>
<p>Block's child statements are run from top to bottom. Except for the root block, every block has a value. If the last statement is an expression, then the value is the expression value, otherwise the value is <code>void</code>.</p>
<h2>Indent</h2>
<p class="detail">For a given line B, if the starting part doesn't belong to a string, what's the effect of its indent? Follow the following steps:</p>
<p class="detail">1. Force connect: Does the previous line A end with <code>\</code>? If not, do next step. If yes, then: No matter how much indent, the line is parsed as if connected to the end of last line, then skip to step 5. If failing to parse then skip to step 6. (Terminology: "connect" in these steps means concatenation of two lines with a space inserted between them. The indent of the second line doesn't count.)</p>
<p class="detail">2. Juxtaposition: In above code does there exist a line A satisfying that B's indent is equal to A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent, and A is not connected or force connected (Terminology: the "connected" one means the right-hand side after connect, while the "connector" means the left-hand side)? If not, do the next step. If yes, then: A's starting part and B's starting part is parsed as the "juxtaposition" relation, then skip to step 5. If failing to parse, skip to step 4.</p>
<p class="detail">3. Hierarchical: In above code does there exist a line A satisfying that B's indent is greater than A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent, and A is not connected or force connected? If not, do the next step. If yes, then: A's ending part and B's starting part is parsed as the "hierarchical" relation, then skip to step 5. If failing to parse, skip to step 4.</p>
<p class="detail">4. Connect: In above code does there exist a line A satisfying that B's indent is greater than or equal to A's indent, and there's no line between A and B or the indent of any line between A and B is greater than B's indent? If not, then skip to step 6. If yes, then: B is parsed as if it's connected to the end of the statement of A's end. If failing to parse, skip to step 6. For example:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and
    y = 5 then aaa()
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5
    and y = 5 then aaa()
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and
        y = 5 then aaa()
]]></code></pre>
<p>Both equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    if x = 5 and y = 5 then aaa()
]]></code></pre>
<p>Note that for now this is not supported:</p>
<pre><code class="fus-part"><![CDATA[
    a.b <>
        aaa()
    .c()
]]></code></pre>
<p>You need to add a parenthesis pair:</p>
<pre><code class="fus-part"><![CDATA[
    a.b(<>
        aaa()
    ).c()
]]></code></pre>
<p class="detail">5. Succeed and exit.</p>
<p class="detail">6. Fail and exit.</p>
<p>Indents are very suitable to represent some complex statement. For example, you can write:</p>
<pre><code class="fus-part"><![CDATA[
    text: "This is a dog."
    speak: match (<>
        s: @0.toLowerCase()
        text.includes(s)
    )
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p class="detail">One thing different from CoffeeScript is the following code:</p>
<pre class="detail"><code><![CDATA[
    a.b aaa
    .c()
]]></code></pre>
<p class="detail">CoffeeScript compiles it into <code>a.b(aaa).c()</code>, but we strictly follow the rule above to compile it as <code>a.b(aaa.c())</code>. If you want the CoffeeScript effect, you should add parentheses:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a.b(aaa)
    .c()
]]></code></pre>
<h2>&lt;&lt; and &gt;&gt;</h2>
<p>Usually, Splitting one line into several lines will add readability. But sometimes things are just the opposite - you will find combining several short lines into one makes it beautiful, particularly when you have many such "several lines". For example:</p>
<pre><code class="fus-part"><![CDATA[
    A: class << aaa: 1 >>
    B: class << bbb: 1 >>
    C: class << ccc: 1 >>
    D: class << ddd: 1 >>
    E: class << eee: 1 >>
]]></code></pre>
<p>It's equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    A: class
        aaa: 1
    B: class
        bbb: 1
    C: class
        ccc: 1
    D: class
        ddd: 1
    E: class
        eee: 1
]]></code></pre>
<p>This leverages the power of <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. <code>&lt;&lt;</code> means to indent one level, and <code>&gt;&gt;</code> means to unindent one level.</p>
<p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> must be closed in one line. That is, multiple lines can be combined into 1 line, but not into 2 lines.</p>
<p>These 2 symbols, used together with semicolons and commas, can achieve the maximum combination effect. Semicolons combine lines, but object properties, array elements and class properties need to be combined through commas.</p>
<p class="detail">After <code>&gt;&gt;</code> there can be a semicolon or comma, but it's optional. For example:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    A: class << aaa: x -> << x + 1 >>, bbb: 3 >>
    if aaa << task1() >> else << task2() >>; commonTask()
]]></code></pre>
<p class="detail">Here the semicolon and comma can be omitted.</p>
<h2>Version Line</h2>
<p>The first line of each file must be version line. It's usually in one line so we call it "version line", but it can be in multiple lines. Version line's syntax:</p>
<!-- version -->
<pre><code><![CDATA[
    [...][fus][...] [-]0.6.0[, (radical | compatible) | (capitalized new | manual new) | (node import | node export | node modules | es modules)]...
]]></code></pre>
<p>Default value is:</p>
<pre><code><![CDATA[
    compatible, capitalized new, es modules
]]></code></pre>
<p>The items separated by comma after the version number can't be duplicated. Examples of version line:</p>
<!-- version -->
<pre><code><![CDATA[
    0.6.0
    fus 0.6.0
    fus -0.6.0
    0.6.0, node modules
    0.6.0, compatible, capitalized new
    0.6.0, compatible, capitalized new, node import
    0.6.0, radical, manual new
]]></code></pre>
<p>Version number must be written. As long as the number is not greater than the FutureScript version you've installed, the code will be run according to the specification of the file's version. This is because any version you install contains all historical compilers (at least as much as possible). This is exactly the difference between FutureScript and other languages. You can even use different versions for different files in one project.</p>
<p>Another benefit of writing version number is that when you hand your file to somebody else, he will know the version, so that he can better modify it.</p>
<p>This article only describes one version.</p>
<p>When you want to write the version line in multiple lines, a brace must be added. The left (opening) brace must be in the first line. A comma between the version number and the left brace is optional. For example:</p>
<!-- version -->
<pre><code><![CDATA[
    0.6.0 {
        radical
        node modules
    }
]]></code></pre>
<p>If the file extension isn't <code>.fus</code> or it has no extension, then there must be a <code>fus</code> before the version number. If the file extension is <code>.fus</code>, it's not necessary, but highly recommended, because your text editor can recognize it so that the syntax can be highlighted.</p>
<p>The difference between "radical mode" and "compatible mode" is: radical mode encourages single-argument functions. Did you find the multiple-argument paradigm makes things complicated? If every function can take at most one argument, this argument can be an array, which can also achieve the similar functionality. But this change is too big, so we don't enable it by default. The default mode is compatible mode, in which you can still use all features of multiple-argument functions.</p>
<p>In radical mode, <code>@</code> means JS's <code>arguments[0]</code>. In compatible mode, <code>@</code> means JS's <code>arguments</code>.</p>
<p>All examples in this article are for compatible mode. In radical mode some code needs modification.</p>
<p>FutureScript code can be used by JS. JS code can also be used by FutureScript.</p>
<p><code>capitalized new</code> means you don't need to add <code>new</code> when creating an instance of a class. The compiler will automatically add the <code>new</code> to the generated code. It depends on the name of the function or class. If it's capitalized then it will add <code>new</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    animal: Animal() # var animal = new Animal();
]]></code></pre>
<p>This is by default.</p>
<p class="detail">Two forms can be recognized: variable and the normal dot (<code>x.y</code>, it will check <code>y</code>). Things like <code>x."y"</code>或<code>x.y'</code> can't be recognized. For example:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    aaa."bbb".Ccc() # new can be omitted
    new aaa.bbb."Ccc"() # new can't be omitted
]]></code></pre>
<p><code>manual new</code> is just the traditional way. When creating instance of a class you should add <code>new</code>.</p>
<p><code>node import</code> means all imports are compiled into Node.js imports (i.e. <code>require</code>). <code>node export</code> means all exports are compiled into Node.js exports (i.e. <code>exports</code> and <code>module.exports</code>). <code>node modules</code>means to do both. <code>es modules</code> means to do neither (i.e. comply with ES6). For details, see the "module" section.</p>
<p class="detail">The generated JS code is in strict mode。</p>
<h2>Comment</h2>
<p>Use <code>#</code> (inline) and <code>###</code> (formatted), similar to CoffeeScript. But one thing different is that CoffeeScript's <code>###</code> is compiled for all occurrences, while our <code>###</code> is compiled only when the opening <code>###</code> is immediately below the version line (or there are only whitespaces between them) and the right side of the closing <code>###</code> doesn't have any non-whitespace character, otherwise it will be ignored by the compiler. To comply with JS, the <code>*/</code> in the comment will be compiled into two spaces.</p>
<h1>Fundamentals</h1>
<h2>Function</h2>
<p>There are 3 ways to create a function: <code>-&gt;</code>, <code>&lt;&gt;</code>, <code>--</code>. <code>&lt;&gt;</code> and <code>--</code> are shorthand for no parameter. Unlike CoffeeScript, when there's only 1 parameter the parenthesis pair can be omitted.</p>
<pre><code class="fus-part"><![CDATA[
    # both are valid
    a: x -> x + 1
    a: (x) -> x + 1
]]></code></pre>
<p>If there's no parameter, then your must use either of these forms:</p>
<pre><code class="fus-part"><![CDATA[
    a: <> Math.random()
    a: -- Math.random()
    a: () -> Math.random()
]]></code></pre>
<p>Multiple-parameter is allowed, but must be within a parenthesis pair:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x, y) -> x * y
]]></code></pre>
<p>If it's single-parameter, and this parameter is an array, then we can use a form similar to "destructuring assignment":</p>
<pre><code class="fus-part"><![CDATA[
    a: [x, y] -> x * y
]]></code></pre>
<p>With this, radical mode have become truly useful. You can use <code>a[1, 2]</code> to call it (we'll discuss the details later). In fact, if a purpose can be achieved by multiple-parameter, it can also be achieved by the single array parameter, and even more pure. So, in radical mode we discourage the use of multiple parameters (Multiple-parameter is partially supported in radical mode. You can't use <code>@</code> to denote the arguments after the first argument).</p>
<p>Inside <code>&lt;&gt;</code>, we can use <code>@</code>. <code>@</code> supersedes JS's <code>arguments</code> (compatible mode) or <code>arguments[0]</code> (radical mode). It's so handy that in many cases you'd like to take no parameter. For example, we can write:</p>
<pre><code class="fus-part"><![CDATA[
    add: <> @0 + @1
    console.log add(2, 3) # output 5
]]></code></pre>
<p>Parameter can have default value:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x ifvoid: 0, y ifvoid: 0) -> x * y
    b: [x ifvoid: 0, y ifvoid: 0] -> x * y
]]></code></pre>
<p>If it has a default value, then there must be a parenthesis pair (or bracket pair) outside even if there's only 1 parameter.</p>
<p>If it's <code>ifvoid</code> default, then <code>ifvoid</code> can be omitted. So the above example can be simplified to:</p>
<pre><code class="fus-part"><![CDATA[
    a: (x: 0, y: 0) -> x * y
    b: [x: 0, y: 0] -> x * y
]]></code></pre>
<p>Besides <code>ifvoid</code> default, there's also <code>ifnull</code> default. We'll discuss that later.</p>
<p>The following table lists the detailed differences between the 3 function symbols:</p>
<table class="table">
    <tr>
        <th></th>
        <th>-&gt;</th>
        <th>&lt;&gt;</th>
        <th>--</th>
    </tr>
    <tr>
        <td>Parameter</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>@</td>
        <td>No</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>fun</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Features</td>
        <td>Many</td>
        <td>All. Can simulate the other 2</td>
        <td>Fewer</td>
    </tr>
    <tr>
        <td>Conciseness</td>
        <td>Concise</td>
        <td>Usually very concise, but sometimes not</td>
        <td>Very concise</td>
    </tr>
</table>
<p>For example, for the use of <code>@</code>, the following code:</p>
<pre><code class="fus-part"><![CDATA[
    outer: <>
        inner: x -> @
]]></code></pre>
<p>Here the <code>@</code> doesn't mean <code>inner</code>'s argument, but mean <code>outer</code>'s argument, because the grammar of <code>-&gt;</code> doesn't define <code>@</code>.</p>
<p><code>fun</code> is a keyword, meaning "this function". It's usually written in a recursive function. If the function name is very long, it can reduce your typed characters. It even enables you to use a recursive function without naming it.</p>
<p>Similarly, because the grammar of <code>--</code> doesn't define <code>fun</code>, the <code>fun</code> inside <code>--</code> means the outer <code>-&gt;</code> or <code>&lt;&gt;</code> function.</p>
<p>Inner parameter can't have the same name as any of outer parameters. This is stricter than CoffeeScript and JS. It might be less strict in later versions.</p>
<p>We have known that member access all uses <code>.</code>. Another benefit of it is that in function call you can omit parentheses and use brackets directly.</p>
<p>Function call has 4 notations: space, parenthesis <code>()</code>, bracket <code>[]</code>, and brace <code>{}</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a(2)
    a 2 # equivalent to above
    a[3, 4, 5] # a([3, 4, 5])
    a{prop: true} # a({prop: true})
    a(3, 4, 5)
]]></code></pre>
<p>In multiple-argument function call a parenthesis pair must be added. This is different from CoffeeScript. Space call is only applicable in single-argument function call. And of course we all know that if it takes no argument then <code>()</code> must be added.</p>
<p>In CoffeeScript, if the passed argument is itself a function which takes no parameters, then it could be written as:</p>
<pre><code class="coffee"><![CDATA[
    abc -> Math.random()
]]></code></pre>
<p>Because CoffeeScript understands it as:</p>
<pre><code class="coffee"><![CDATA[
    abc (-> Math.random())
]]></code></pre>
<p>But in FutureScript you couldn't write so, because the compiler will treat it as a function with parameter <code>abc</code>. You must write either of these:</p>
<pre><code class="fus-part"><![CDATA[
    # pass a function as argument to abc
    abc <> Math.random()
    abc -- Math.random()
    abc () -> Math.random()
]]></code></pre>
<p>We can also use <code>'</code> to achieve the "splat" effect:</p>
<pre><code class="fus-part"><![CDATA[
    awardMedals' contenders # awardMedals.apply(null, contenders)
]]></code></pre>
<p>Equivalent to ES6's</p>
<pre><code class="js"><![CDATA[
    awardMedals(...contenders)
]]></code></pre>
<p>The apostrophe <code>'</code> is called variant. <code>'</code> is a unique symbol in FutureScript. Not limited to this form. We will discuss it later.</p>
<p>Note that these 2 functions are different:</p>
<pre><code class="fus-part"><![CDATA[
    a{prop: true}.b # a({prop: true}).b
    a {prop: true}.b # a({prop: true}.b)
]]></code></pre>
<p>Every function has a return value - the value of the function block, so we don't need to use <code>return</code>. What does the value of the function block mean? The accurate definition is described before. Now I give an informal definition: It's just the last statement's value in that function. If the last statement isn't an expression, then it's <code>void</code>. This rule is very important - it's the core of the functional programming. For example:</p>
<pre><code class="fus-part"><![CDATA[
    calc: (x, y) ->
        a: x * x
        b: y * y
        a + b
    calc(2, 3) # returns 13
]]></code></pre>
<p>This rule applies to not only the function block, but blocks inside <code>if...then...else...</code>, and all other blocks (except the root block).</p>
<p>Unlike CoffeeScript, we don't have fat arrow <code>=&gt;</code>, because I think JavaScript's changeable meaning of <code>this</code> isn't a good design. It should always point to the current object.</p>
<p class="detail">The mapping between our function and CoffeeScript's function is as follows:</p>
<ul class="detail">
    <li>Class method and constructor (including nested class's method and constructor): CoffeeScript thin arrow</li>
    <li>Inside class method and constructor (excluding nested class's method or constructor, but including those inside nested class's method and constructor: CoffeeScript fat arrow</li>
    <li>The rest: CoffeeScript thin arrow</li>
</ul>
<h2>Assignment and Declaration</h2>
<p>Use <code>:</code> and <code>as</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a: "hello world" # var a = "hello world";
    3 as b # var b = 3;
]]></code></pre>
<p>Note that <code>:</code> doesn't form an expression, but <code>as</code> forms an expression. For example:</p>
<pre><code class="fus-part"><![CDATA[
    abc: <>
        a: 1
]]></code></pre>
<p>Run <code>abc()</code> and the return value is <code>void</code> not <code>1</code>. But</p>
<pre><code class="fus-part"><![CDATA[
    abc: <>
        1 as a
]]></code></pre>
<p>Run <code>abc()</code> and the return value is <code>1</code>.</p>
<p>Variables don't need, and shouldn't be declared, because our variables are automatically declared. This mechanism is like CoffeeScript, but with notable difference mainly in dealing with the inner and outer level:</p>
<ul>
    <li>CoffeeScript: If it doesn't exist in the <b>preceding outer level</b>, then it will be compiled to "declare and assign". If exist, then it will be compiled to "assign only".</li>
    <li>FutureScript: If it doesn't exist in the <b>outer level</b>, then it will be compiled to "declare and assign". If exist, then it will be compiled to "assign only".</li>
</ul>
<p>These two codes are equivalent. Both are compiled to a single variable:</p>
<p>CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    a = 3
    ->
        a = 5
]]></code></pre>
<p>FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    a: 3
    --
        a: 5
]]></code></pre>
<p>But these two are different:</p>
<p>CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    ->
        a = 5
    a = 3
]]></code></pre>
<p>CoffeeScript compiles it to two variables with the same name <code>a</code>. But in FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    --
        a: 5
    a: 3
]]></code></pre>
<p>will be compiled to a single variable <code>a</code>.</p>
<p>Auto-declaration is inspired by CoffeeScript. I think it's one of the best features in CoffeeScript. Maybe many people don't agree, feeling it's a bad feature because it inhibits declaring a same-name variable in inner level. But this is not the truth. In a large project, it's reasonable for different developers to manage different files, for modules are isolated; but it isn't reasonable for different developers to manage the inner and outer level of a file respectively, for it will cause chaos. Now that a file's inner and outer level should be managed as a whole, when you name an inner-level variable, it's not difficult to pay attention to the outer level, so there's really no need to support the same-name variable in inner level. We even do it more thoroughly than CoffeeScript.</p>
<p><code>:</code> supports array destructuring assignment (without nested). For example:</p>
<pre><code class="fus-part"><![CDATA[
    [a, b]: [b, a] # swap a and b
]]></code></pre>
<p>The effect or a colon is just to let the left side have the value of the right side, be it in object or in assignment.</p>
<p><code>:</code> supports assigning a value to multiple identifiers. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a, b: 1 # both a and b are 1
]]></code></pre>
<p>If a name isn't a FutureScript keyword, it can be a variable name. Even JS keywords such as <code>function</code> can be variable names. But JS keywords can't be global variable names.</p>
<h2>Module</h2>
<p>If you want to continue using Node's <code>require</code>, <code>exports</code> and <code>module.exports</code>, you can simply skip this section. In FutureScript you can still use them as usual.</p>
<p>We know that Node has its own module system, but the problem is that this system doesn't belong to ES6. ES6 defines a native JS module syntax. Because FutureScript is based on JS, our native module syntax is based on ES6.</p>
<p>One file is to one module. Syntaxes related to module are <code>import</code>, <code>export</code> and <code>'export</code>.</p>
<pre><code class="fus-part"><![CDATA[
    main: import "lib"
]]></code></pre>
<p>or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" as main
]]></code></pre>
<p>Both mean to import ES6's default export, equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import main from "lib";
]]></code></pre>
<p>If the version line uses the default value, it will be compiled to the above JS. But the wonderful thing is: if the version line has <code>node import</code> or <code>node modules</code>, the same code will be compiled into:</p>
<pre><code class="js"><![CDATA[
    var main = require("lib");
]]></code></pre>
<p>Without modifying your code, you can control whether to use Node module system or ES6 module system for all <code>import</code> in this file. So now <code>import</code> can replace <code>require</code>.</p>
<p>In fact, because currently Node.js and browsers only provide partial ES6 support, you may have to use Babel to convert it to ES5, and Babel will automatically convert your <code>import</code> to use the Node module system, so even if you don't specify it in the version line, I think it doesn't matter (but there may be slight differences).</p>
<p>To import all named exports:</p>
<pre><code class="fus-part"><![CDATA[
    lib: import "lib" all
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" all as lib
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import * as lib from "lib";
]]></code></pre>
<p>To import specified named exports:</p>
<pre><code class="fus-part"><![CDATA[
    {fun1, fun2 as f2}: import "lib"
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    import "lib" as {fun1, fun2 as f2}
]]></code></pre>
<p>Equivalent to JS's:</p>
<pre><code class="js"><![CDATA[
    import {fun1, fun2 as f2} from "lib";
]]></code></pre>
<p>Importing both default export and named exports is not supported. If you have this requirement please split them into two statements. I think it's not good for a module to have both default export and named exports.</p>
<p class="detail">Note, that some examples above use the feature that <code>all</code> can be omitted. The complete form is:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    {fun1, fun2 as f2}: import "lib" all
    import "lib" all as {fun1, fun2 as f2}
]]></code></pre>
<p class="detail"><code>import</code> can only be followed by an inline normal string. The string can't have interpolations (but can have escapes). <code>import</code> can't have both colon and <code>as</code>. These are correct <code>import</code> statements:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    import "./abc" as abc
    abc: import "./abc"
    abc: import "abc" all
    import "abc"
    import "\u0041"
]]></code></pre>
<p class="detail">These are illegal <code>import</code> statements:</p>
<pre class="detail"><code><![CDATA[
    import("abc")
    import "./a" + "bc" # But this is legal as import expression
    import "./\(filename)"
    import v"abc"
    aaa: import "bbb" as ccc
]]></code></pre>
<p>An <code>import</code> assignment is not a normal assignment. It is "binding", like in ES6. So it's limited to variables. It can't be assigned to object properties. There can't be <code>ifvoid</code>, <code>ifnull</code> or <code>'</code> before the colon.</p>
<p>When we use Node we often come into this situation：Each file has a large number of imports, most of which are duplicated, but can't be omitted. Of course you can create a new module and put everything into it, then export, so each module only needs to import this new module. For example:</p>
<pre><code class="fus-part"><![CDATA[
    aaa: import "aaa"
    bbb: import "bbb"
    ccc: import "ccc"
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>You create a <code>all.fus</code> file and put the 3 <code>import</code> into it and write the following in the original file:</p>
<pre><code class="fus-part"><![CDATA[
    all: import "./all"
    all.aaa()
    all.bbb()
    all.ccc()
]]></code></pre>
<p>But the problem is: When calling, <code>all.</code> must be added. So it seems not much shorter than before.</p>
<p>FutureScript has a unique "batch import" feature (even ES6 doesn't have). If there's <code>all</code> but no colon or <code>as</code>, then it will be compiled to batch import. It will import all named exports (except the default export) and let them all be variable names. So, we can write:</p>
<pre><code class="fus-part"><![CDATA[
    import "./all" all
    aaa()
    bbb()
    ccc()
]]></code></pre>
<p>This feature has an important property: When compiling, it needs to generate variable names by reading the imported module. To ensure the path's parsing mechanism is the same as runtime, we made the parser as simple as possible. So it only supports paths starting with <code>"./"</code>, <code>"../"</code> or <code>"/"</code>. So this is a limitation: it's only suitable for importing another module in the current project, not suitable for importing directly from another project by using the module name. So if you want to import between projects, you need to have a "manifest" module as the "middle" in the current project.</p>
<p>"Batch import" doesn't introduce global variables, so it's not evil. These variables are invisible in other modules, unless other modules batch-import them too.</p>
<p>If A batch imports B, and if some B's named export (imported as A's variable) happen to be a keyword of A's FutureScript version, then this variable will be inaccessible, but it won't cause error.</p>
<p>A normally imported module can be a Fus or JS file, but a batch imported module must be a Fus file (any version number is allowed).</p>
<p>In the above we introduced <code>import</code> statement. <code>import</code> can also act as expression. The syntax is: <code>import "module-name"</code>. It can't be followed by <code>as</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    import "abc"
    import "abc" + 1
    a: import "abc" + 1
]]></code></pre>
<p>So the syntax of <code>import</code> expression gives you more freedom, but it can only import default exports. Also, if used together with assignment, then it's a normal assignment, not a binding.</p>
<p>When export, we can use 4 syntaxes: <code>export</code>, <code>'export</code>, <code>export as</code>, <code>export ... as</code>. These are all correct:</p>
<pre><code class="fus-part"><![CDATA[
    multiply'export: <> @0 * @1
    mp: (<> @0 * @1) export as multiply
    mp: (<> @0 * @1) as multiply'export
    abc export as def
    export abc as def
    export abc
    export: abc # note that this is different from above
    export: <> @0 * @1
]]></code></pre>
<p>These are illegal:</p>
<pre><code><![CDATA[
    abc export def
    export {abc}
    export multiply: <> @0 * @1
    obj.multiply'export: <> @0 * @1
]]></code></pre>
<p>Note that <code>abc export as def</code> and <code>export abc as def</code> behave similarly, but with two differences. One is obvious: the former is an expression statement while the latter is a command statement. The other is subtle: The former <code>abc</code> is treated as an expression, while the latter <code>abc</code> is treated as a variable. This makes it so that: The former is not a binding, but the latter is a binding (can have the benefit of ES6 module's variable binding).</p>
<p>If a statement starts with <code>export:</code>, it means ES6's default export. For example:</p>
<pre><code class="fus-part"><![CDATA[
    export: abc
]]></code></pre>
<p>If the version line has <code>node export</code> or <code>node modules</code>, this statement will be compiled into:</p>
<pre><code class="js"><![CDATA[
    module.exports = abc;
]]></code></pre>
<p class="detail">This kind of statement can appear only once. If it appears, then there can't be any other exports, otherwise a compiler error will be raised. This is because (as mentioned before) it's not good to have both default export and named exports in one module. Although for compatibility FutureScript supports importing a JS module of this architecture, for Fus module we can dismiss this architecture.</p>
<p class="detail">Default export can be in this form:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    export abc as default
]]></code></pre>
<p class="detail">So default export is actually a special named export (for details see ES6 articles). If you name it <code>default</code> then it's default export.</p>
<p class="detail">So these two:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    export abc as default
    export: abc
]]></code></pre>
<p class="detail">They behave similarly. The only difference is: The former <code>abc</code> is treated as a variable, so it's a binding. The latter <code>abc</code> is treated as an expression, so it's not a binding. (This is the same as ES6's rule. ES6's <code>export {... as default}</code> and <code>export default ...</code> also has such difference.)</p>
<p>Imports and exports must be in the outermost level, because it's based on ES6. Our imports are static, not dynamic, so it's stricter than Node. But I know in some cases you may need to dynamic import, you can use <code>require</code> instead of the native module syntax.</p>
<h1>Data</h1>
<h2>String and Regular Expression</h2>
<p>Inline string:</p>
<pre><code class="fus-part"><![CDATA[
    str: "Welcome to FutureScript!"
]]></code></pre>
<p>Formatted string:</p>
<pre><code class="fus-part"><![CDATA[
    htmlStr: "
        <p>
            Welcome to "FutureScript"!
        </p>
    "
]]></code></pre>
<p>The above string is equal to CoffeeScript's</p>
<pre><code class="coffee"><![CDATA[
    htmlStr = """
        <p>
            Welcome to "FutureScript"!
        </p>
    """
]]></code></pre>
<p>You may wonder why we can use only 1 quotation mark to wrap a text block (the text itself has quotation marks). The secret is that we require every indent in the string to be greater than the indent of the quotation mark, and require that the indent of the opening quotation mark be the same as that of the closing quotation mark. So no matter how many quotation marks there are inside the string, they won't affect the compiler.</p>
<p>The opening quotation mark of a formatted string must be followed immediately by a newline (the 2 newlines for starting and ending doesn't count towards the string characters). In the line of the closing quotation mark, before the quotation mark there should only be whitespaces. Within a line inside the string, the left part of the indent doesn't count towards the string characters until an indent whitespace exceeds the "minimum indent in the string". Note: Here "minimum indent" doesn't include empty lines.</p>
<p>The inside of a formatted string can't be all whitespaces (except those in escape form). For example, these are all illegal:</p>
<pre><code><![CDATA[
    str: "
    "

    str: "

    "
]]></code></pre>
<p>Although this also represents a space, it's valid:</p>
<pre><code class="fus-part"><![CDATA[
    str: "
        \x20
    "
]]></code></pre>
<p class="detail">How does the compiler determine if it's inline or formatted? It checks the character immediately after the opening quotation mark. If it's newline, then formatted. If otherwise then inline.</p>
<p>We don't use apostrophe to represent strings, because I feel when you want to use it, if the string is very long, you can use formatted <code>"</code>; If the string is very short, such as <code>'"'</code>, this just add very little readability. I'd rather use<code>"\""</code>. Neither of these has an obvious advantage over the double quotation mark. So, better not spend the precious symbol resource on this. Also, double quotation mark is consistent with JSON.</p>
<p>Like CoffeeScript, we support string interpolation, but we use <code>\(...)</code>.</p>
<pre><code class="fus-part"><![CDATA[
    str: "Today is \(year)-\(month)-\(day)."
]]></code></pre>
<p>An interpolation can't occupy multiple lines. For now we don't support interpolation with quotation marks in it (i.e. nested strings). In fact, even if we support it, it will look very complicated and thus not beautiful. You may well assign it to a variable and interpolate the variable.</p>
<p>In the above we introduced the normal string. Besides normal string there are special string and string extension. What's a string extension? Regular expression is a typical example.</p>
<p>To represent a regular expression, we use <code>r"..."</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    str.search(r"^\d{3}-\d{3}-\d{4}$")
]]></code></pre>
<p>The inline regular expression suppresses most features of <code>\</code> except these 2：<code>\"</code> and the line-end connectable <code>\</code>. Note, that in JS <code>"</code> and <code>#</code> can be written directly in a regular expression, but here we must use <code>\"</code> and <code>\#</code>, for these 2 characters have special meanings.</p>
<p>Regular expression can have interpolations. It interpolates strings:</p>
<pre><code class="fus-part"><![CDATA[
    first: "hello"
    second: "world"
    r"#(first)-#(second)"
]]></code></pre>
<p>Equivalent to CoffeeScript, if the regular expression interpolation is a normal string, it will be verbose if you want to express the <code>\</code> character, so it's recommended to use it only to insert non-symbol characters.</p>
<p>Representing flagged regular expression is also possible:</p>
<pre><code class="fus-part"><![CDATA[
    r"\d{3}-\d{3}-\d{4}"gim
]]></code></pre>
<p>An example of formatted regular expression:</p>
<pre><code class="fus-part"><![CDATA[
    str.search(r"
        ^
        \d{3} # first
        -
        \d{3} # second
        -
        \d{4} # third
        $
    ")
]]></code></pre>
<p>The difference of a formatted regular expression is: Whitespace and newline are meaningless. Support comments. Simpler to represent double quotes. There must be at least one space before the comment character <code>#</code>. This is different from normal comments.</p>
<p>Verbatim string is inspired by C#. A verbatim string is represented by <code>v"..."</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    path: v"C:\Windows\System"
]]></code></pre>
<p>A verbatim string suppresses all the features of <code>\</code>, so you can't connect using <code>\</code> in line end. In inline verbatim strings you can't represent double quotation marks.</p>
<p>So in summary, if the opening <code>"</code> is preceded immediately by a letter, then it means a string or string extension.</p>
<p class="detail">In essence, the content enclosed by quotation marks in a regular expression is a string. This is different from JS and CoffeeScript. Even the comment in a formatted regular expression belongs to a string in essence (but just got removed during conversion). Note, that the conversion is at runtime not compile time. Because it's possible to have interpolations, we can't convert it while compiling.</p>
<p>There's another difference from CoffeeScript. In CoffeeScript:</p>
<pre><code class="coffee"><![CDATA[
    mobyDick = "Call me Ishmael. Some years ago --
    never mind how long precisely -- having little
    or no money in my purse, and nothing particular
    to interest me on shore, I thought I would sail
    about a little and see the watery part of the
    world..."
]]></code></pre>
<p>This will be compiled to "join multiple lines by a space". But we do not support. One reason is that it's not compatible to our grammar. Another reason is that this only applies to western languages. For example, if it's Chinese then adding a space is wrong. So I think it's better to use<code>\</code> to join. If it's English, then manually add a space before it.</p>
<p>The following table lists the escape rule for all kinds (the escape during conversion is not included, for example the <code>\</code> in regular expression itself):</p>
<table class="table">
    <tr>
        <th></th>
        <th>Inline "</th>
        <th>Formatted "</th>
        <th>Inline v"</th>
        <th>Formatted v"</th>
        <th>Inline r"</th>
        <th>Formatted r"</th>
        <th>Inline js"</th>
        <th>Formatted js"</th>
    </tr>
    <tr>
        <td>\ Normal Escape</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>\"</td>
        <td>Yes</td>
        <td>Yes but not required</td>
        <td>No</td>
        <td>Not required and no</td>
        <td>Yes</td>
        <td>Not required and no</td>
        <td>No</td>
        <td>Not required and no</td>
    </tr>
    <tr>
        <td>\ Connect</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Interpolation</td>
        <td>\(...)</td>
        <td>\(...)</td>
        <td>No</td>
        <td>No</td>
        <td>#(...)</td>
        <td>#(...)</td>
        <td>No</td>
        <td>No</td>
    </tr>
</table>
<h2>Array</h2>
<p>The bracket pair <code>[...]</code> is to represent an array literal or an array-like thing (in destructuring assignment). No other uses.</p>
<p>The dot <code>.</code> is to access an object property. Because an array is also an object, JS's <code>arr[3]</code> is superseded by <code>arr.3</code>, which is more consistent. In fact an array is an object whose property name is the index (converted to string). If you don't believe you can test by typing <code>Object.keys(arr)</code>. JS is different than other languages in this part, but it's not a bad part, because the concept is consistent.</p>
<p>Of course, when used together with fractions it may look unsuitable. In this case you can add a parenthesis pair. Compare the following:</p>
<pre><code class="fus-part"><![CDATA[
    x.1 + x.2 + 3.5
    x.(1) + x.(2) + 3.5 # the same as above but looks better
    x1.1 + x1.2 + 2.4
    x1.(1) + x1.(2) + 2.4 # the same as above but looks much better
]]></code></pre>
<p><code>a.(b)</code> is equivalent to JS's <code>a[b]</code>.</p>
<p>The notation of array literal is the same as CoffeeScript.</p>
<h2>Object</h2>
<p>The notation of object literal is almost the same as CoffeeScript, except that it must be enclosed with a brace pair <code>{...}</code>, which can't be omitted.</p>
<p>In object property access, if the left side of a dot <code>.</code> is a number, then the number must be enclosed by parentheses, for example <code>(1).toString()</code>. This restriction is to avoid ambiguity, such as <code>1.3</code>. You may argue that there's no ambiguity because <code>1</code> is unlikely to be an array, then how about <code>1.3.a</code>? It feels weird, less intuitive than <code>(1.3).a</code>. So in this point we are stricter than JS (JS doesn't allow <code>1.a</code>, but allow <code>1.3.a</code>).</p>
<h2>Literal</h2>
<p>There are the following kinds of literal:</p>
<ul>
    <li>Number literal</li>
    <li>Boolean literal</li>
    <li>String literal</li>
    <li>String extension literal</li>
    <li><code>null</code> literal</li>
    <li><code>void</code> literal</li>
    <li>Object literal</li>
    <li>Array literal</li>
    <li>Function literal</li>
    <li>Class literal</li>
</ul>
<p>A literal is an expression. Its difference from a normal expression is:</p>
<ul>
    <li>A literal is a constant.</li>
    <li>A literal by itself isn't an identifier (but can contain identifiers).</li>
    <li>A literal belongs to some certain type (note that "type" is wider than "class" in range).</li>
    <li>A literal is usually the source of creating a value of this certain type.</li>
    <li>A literal has a specific notation.</li>
</ul>
<h2>Context</h2>
<p>We have 6 keywords or symbols to denote the contexts, as follows:</p>
<ul>
    <li>Current object: <code>me</code></li>
    <li>Current object's class: <code>Me</code></li>
    <li>Parent object's member: <code>super</code></li>
    <li>Current function in the closure: <code>fun</code></li>
    <li>Current argument: <code>@</code></li>
    <li>The left side of the colon in assignment: <code>self</code></li>
</ul>
<p>The dot immediately after <code>@</code> can be omitted, except that the dot is followed by <code>(</code> or string or string extension such as <code>"</code>, <code>v"</code> and <code>r"</code>.</p>
<h1>Control Flow</h1>
<h2>Logical Operation</h2>
<ul style="font-family: monospace;">
    <li>=</li>
    <li>/= (not =, not=, ≠)</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;= (≤)</li>
    <li>&gt;= (≥)</li>
    <li>and</li>
    <li>or</li>
    <li>not</li>
</ul>
<p>The equals sign <code>=</code> is just to determine equality. No longer need to distinguish between <code>=</code>, <code>==</code> and <code>===</code>.</p>
<p><code>/=</code> or <code>≠</code> means inequality. It can also be written as <code>not =</code>, where the space can be omitted. The highlight here is <code>≠</code>. If you use Mac, you can directly input <code>≠</code> by holding "Alt" key and pressing "=". Mac natively supports inputting inequality signs. If you use Windows, you can define shortcut keys in your editor, so actually everyone can input <code>≠</code> easily. This greatly improves readability.</p>
<p>Why don't we use <code>!=</code>? Because <code>!</code> isn't used by FutureScript so far, I really don't want a precious symbol to be only usable with <code>=</code>. <code>/=</code> also looks more like <code>≠</code> than <code>!=</code>.</p>
<p>Like CoffeeScript, we support chained comparison:</p>
<pre><code><![CDATA[
    if 200 ≤ statusCode < 300
        console.log "success"
]]></code></pre>
<p>But our limitation is more than CoffeeScript. You can only compare in the same direction. Such is not supported:</p>
<pre><code><![CDATA[
    if a < b > c
        console.log "success"
]]></code></pre>
<p>For logical operation, the biggest difference in FutureScript is the precedence of <code>not</code>. <code>not</code> is lowered, only higher than <code>and</code> and <code>or</code>. This means we can omit many parentheses. You must have complained in JS you have to write:</p>
<pre><code class="js"><![CDATA[
    if !(abc instanceof Abc) doTask();
]]></code></pre>
<p>But now we can:</p>
<pre><code><![CDATA[
    if not abc instanceof Abc
        doTask()
]]></code></pre>
<p>But in fact this example is illegal, because we don't have <code>instanceof</code>. We use <code>is</code>. You can write <code>not abc is Abc</code> but it's a bit ugly (so we support <code>abc isnt Abc</code>). So are there any beautiful examples? Yes, in this example you can also omit parentheses:</p>
<pre><code class="fus-part"><![CDATA[
    if not 200 ≤ statusCode < 300
        console.log "failure"
]]></code></pre>
<p>Back to the inequality sign. You can also use <code>not ... =</code>. These 5 forms behaves the same:</p>
<pre><code class="fus-part"><![CDATA[
    if statusCode ≠ 200 throw
    if statusCode /= 200 throw
    if statusCode not= 200 throw
    if statusCode not = 200 throw
    if not statusCode = 200 throw
]]></code></pre>
<p class="detail">But <code>not ... =</code> generates different code than the other 3, though the behavior is the same.</p>
<h2>Condition</h2>
<p>Use<code>if</code>, <code>?</code>, <code>then</code>, <code>else</code>, <code>|</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    b:
        if a = 3
            "three"
        else
            "other"
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    b:
        a = 3 ?
            "three"
        else
            "other"
]]></code></pre>
Can be combined into one line:
<pre><code class="fus-part"><![CDATA[
    b: if a = 3 then "three" else "other"
]]></code></pre>
<p>Or</p>
<pre><code class="fus-part"><![CDATA[
    b: a = 3 ? "three" else "other"
]]></code></pre>
<p>Or even</p>
<pre><code class="fus-part"><![CDATA[
    b: a = 3 ? "three" | "other"
]]></code></pre>
<p><code>?</code> is equivalent to <code>then</code>, and <code>|</code> is equivalent to <code>else</code>. This rule is not limited to <code>if</code>, but rather in all the language. Any rule mentioned hereinafter is applicable to its equivalent. For example, the rule of <code>then</code> also applies to <code>?</code>.</p>
<p>When the condition is prefixed, <code>if</code> can be omitted, and <code>then</code> can be omitted if <code>then</code> block isn't an inline block. When <code>if</code> is omitted take note of the precedence problem it may cause. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a if b > 100 then 100 else b
]]></code></pre>
<p>Here if the <code>if</code> is omitted the meaning will be changed, unless a parenthesis pair is added.</p>
<p>When <code>then</code> is followed by a keyword of command statement, <code>then</code> can also be omitted (this also applies to pattern matching, which we will discuss later). For example:</p>
<pre><code class="fus-part"><![CDATA[
    if a > 100 throw new Error()
]]></code></pre>
<p>If there's no <code>else</code> block, then if the condition matches <code>else</code>, the whole <code>if</code> expression's value will be <code>void</code>.</p>
<p>But note that however omitted, you can't omit both <code>if</code> and <code>then</code> in the prefixed-condition form.</p>
<p>Condition can also be postfixed. For example:</p>
<pre><code class="fus-part"><![CDATA[
    console.log("a is true!") if a # if (a) {console.log("a is true!");}
    mood: "happy" if singing # if (singing) {mood = "happy";}
]]></code></pre>
<p class="detail">When condition is postfixed, <code>if</code> can't be omitted. One statement can only have one postfixed <code>if</code>. It must be in the outermost level of a statement (can't be enclosed with parentheses). Also, the block before <code>if</code> can't be a normal block. It can only be an inline block. Because postfixed <code>if</code> must be in the outermost level, so if a colon assignment is before it, then the code between the colon and <code>if</code> should belong to the colon not <code>if</code>.</p>
<p>Another thing different from CoffeeScript is when come across semicolons:</p>
<pre><code class="coffee"><![CDATA[
    if x > 100 then aaa(); bbb()
]]></code></pre>
<p>CoffeeScript treats <code>aaa(); bbb()</code> as child statements. But this rule looks inconsistent with other rules. Also we have unique symbols for this so it can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    if x > 100 << aaa(); bbb() >>
]]></code></pre>
<p>So CoffeeScript's "semicolon rule" is cancelled in our language. In FutureScript, the left and right side of semicolon can pass through any obstacles, provided there's no grammar error.</p>
<h2>Pattern Matching</h2>
<p><code>match</code> can be regarded as an enhanced version of <code>switch</code>, called pattern matching. For example:</p>
<pre><code class="fus-part"><![CDATA[
    day: 3
    text: match day
        1 ? "Mon"
        2 ? "Tue"
        3 ? "Wed"
        4 ? "Thu"
        5 ? "Fri"
        6 ? "Sat"
        |   "Sun"
    # text will be "Wed"
]]></code></pre>
<p>Above is the simplest pattern matching, where <code>day</code> is called the input, and 1, 2, 3... is called patterns.</p>
<p>The "comparison" is by default using <code>=</code> to directly compare the input with a pattern. <code>match</code> can also be followed by not the input, but a comparison function. For example:</p>
<pre><code class="fus-part"><![CDATA[
    statusCode: 404
    message: match <> statusCode >= @0
        600 ? "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
        |     "unsupported"
    # message is "client error"
]]></code></pre>
<p>If using radical mode, the above <code>@0</code> can be simplified to <code>@</code>。</p>
<p><code>else</code> can be combined with a preceding pattern by using <code>or else</code>, but this pattern can't contain <code>then</code>. This is called the combination of <code>else</code> pattern and other pattern, but in essence it's still two patterns. In addition, if <code>or</code> isn't treated as an operator, it can be simplified as <code>,</code>. So the above example can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    message: match <> statusCode >= @0
        600, | "unsupported"
        500  ? "server error"
        400  ? "client error"
        300  ? "redirect"
        200  ? "success"
        100  ? "informational"
]]></code></pre>
<p>When using <code>or else</code> for patterns, <code>or</code> can be omitted. So it can be further simplified to: </p>
<pre><code class="fus-part"><![CDATA[
    message: match <> statusCode >= @0
        600 | "unsupported"
        500 ? "server error"
        400 ? "client error"
        300 ? "redirect"
        200 ? "success"
        100 ? "informational"
]]></code></pre>
<p>Comparison function is very powerful. For example:</p>
<pre><code class="fus-part"><![CDATA[
chessBoard: (pos) -> match <> pos.x = @0.0 and pos.y = @0.1
    [0, 0] ? "king"
    [0, 1] ? "pawn"
    [4, 5] ? "queen"
    |        "empty"
piece: chessBoard {x: 4, y: 5} # will be "queen"
]]></code></pre>
<p>(Note: In radical mode <code>@0.0</code> and <code>@0.1</code> can be simplified to <code>@0</code> and <code>@1</code>.)</p>
<p>Another example:</p>
<pre><code class="fus-part"><![CDATA[
    text: "This is a dog."
    speak: match <> text.includes(@0)
        "cat" ? "meow"
        "dog" ? "woof"
        |       "unknown"
    # speak is "woof"
]]></code></pre>
<p>Once <code>match</code> is followed by a function, it will be recognized as a comparison function. <code>-&gt;</code> or <code>&lt;&gt;</code> must be directly written here. It can't be replaced by a variable.</p>
<p>There are also <code>or</code> pattern and <code>and</code> pattern. <code>or</code> pattern is very commonly used. For example:</p>
<pre><code class="fus-part"><![CDATA[
    day: "Tue"
    action: match day
        "Sat", "Sun" ? "have a rest"
        |              "work"
]]></code></pre>
<p><code>and</code> pattern is less common. But here is an example:</p>
<pre><code class="fus-part"><![CDATA[
    array: ["a", "c", "b", "d"]
    message: match <> array.includes(@0) # note: arr.includes is an ES7 feature
        "a" and "b" and "c" ? "The array includes all of the first 3 letters."
        "a"                 ? "The array includes a."
        "b"                 ? "The array includes b."
        "c"                 ? "The array includes c."
        |                     "The array doesn't include any of the first 3 letters."
]]></code></pre>
<p>From this we know, that the use of <code>or</code> and <code>and</code> as operators are limited within a pattern, for they must be enclosed in a parenthesis pair, otherwise they will be treated as a pattern. But it seems that logical operators are rarely used within patterns.</p>
<p class="detail">作为模式使用时要么全是<code>or</code>，要么全是<code>and</code>，两个不能在一个模式中一起出现，否则编译器会无法判断。括号内的无此限制。</p>
<p class="detail">注意<code>or else</code>是一种特殊的合并写法，并不属于or模式，所以<code>or else</code>可以和<code>and</code>一起出现。</p>
<p>Like <code>if</code>, in pattern matching <code>then</code> block can be indented. In this way we can omit <code>then</code>:</p>
<pre><code class="fus-part"><![CDATA[
    day: 3
    match day
        6
            go bingo
            go dancing
        7
            go church
        |
            go work
]]></code></pre>
<p>We can find that even when simulating the traditional <code>switch</code>, it's shorter than <code>switch</code>.</p>
<h2>Loop</h2>
<p>In fact, loops violates the idea of functional programming. That's why I deliberately take away loops in FutureScript. But I'm confident that FutureScript can do anything that a loop can do, with the same or shorter length of syntax. (This chapter doesn't belong to the FutureScript specification. It just introduces the <code>repeat</code> function in the <code>fus-ext</code> package. This chapter may be outdated. The <code>fus-ext</code> tutorial governs the usage. For convenience, "loop" in this article usually means <code>repeat</code>.)</p>
<p>We can use FutureScript's extension package <code>fus-ext</code> to implement loops.</p>
<pre><code><![CDATA[
    npm install fus-ext
]]></code></pre>
<p>Copy <code>node_modules/fus-ext/examples/manifest.fus</code> file to your code's directory.</p>
<p>You code can be like this:</p>
<!-- version -->
<pre><code class="fus"><![CDATA[
    fus 0.6.0
    import "./manifest" all

    repeat[10, i ->
        console.log "This is \(i) time"
    ]
]]></code></pre>
<p>Here we used the "batch import" feature (for details see the "Module" section above). Note that the export of <code>manifest.fus</code> should match the import of yours. If you want to use <code>node</code> instead of <code>es</code>, then you'll need to make corresponding changes in the version line of the two files.</p>
<p>If the iterator returns <code>break</code> then it means to jump out of the loop, similar to JS's <code>break</code>, but different in essence. Here <code>break</code> is an expression, and only capable of cancelling the remaining cycles, not capable of cancelling the remaining part of the function. If <code>break</code> then the <code>repeat</code> function returns <code>break</code>。This example is a loop, from 0 to 9, but it will jump out on 5:</p>
<pre><code class="fus-part"><![CDATA[
    repeat[10, i ->
        if i < 5
            console.log "This is \(i) time"
        else
            break
    ]
]]></code></pre>
<p>If no count is set, it means forever, equivalent to JS's <code>while (true)</code>:</p>
<pre><code class="fus-part"><![CDATA[
    repeat --
        if abc()
            break
        else
            doSomething()
]]></code></pre>
<p>This corresponds to JS's <code>for</code> loop, from 1 to 10:</p>
<pre><code class="fus-part"><![CDATA[
    repeat{from: 1, to: 10, for: i ->
        console.log i
    }
]]></code></pre>
<p>This corresponds to JS's <code>for</code> loop, from 10 to 1:</p>
<pre><code class="fus-part"><![CDATA[
    repeat{from: 10, to: 1, by: -1, for: i ->
        console.log i
    }
]]></code></pre>
<h2>Recursion</h2>
<p>Recursion is not special, but we added some simpler way. You even don't need to name a recursive function. Just think that if it invokes itself, why it must have a name? Just use the <code>fun</code> keyword and it's OK. For example, if you don't want to use an external library, you can simulate a loop using recursion:</p>
<pre><code class="fus-part"><![CDATA[
    do (i: 0) -> if i < 10
        console.log i
        fun(i + 1)
]]></code></pre>
<h2>Exception</h2>
<p>Use <code>try</code>, <code>catch</code>, <code>finally</code> and <code>throw</code>, like CoffeeScript. For example:</p>
<pre><code class="fus-part"><![CDATA[
    try
        checkDirectory()
        writeFiles()
    catch error
        print error
    finally
        cleanUp()
]]></code></pre>
<p><code>throw</code> can even be followed by nothing. If it's in <code>catch</code> block then compiled into <code>throw catchExceptionVar</code>, otherwise compiled into <code>throw undefined</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    try
        doSth()
    catch error
        console.log "error"
        throw # throw error;
]]></code></pre>
<p>When you want to rethrow an exception in <code>catch</code> block, you can type less.</p>
<p class="detail">If <code>try</code> block or <code>finally</code> block is an inline block, then it must occupy the whole line.</p>
<h2>Asynchronous</h2>
<p><code>'wait</code> makes an asynchronous function internally synchronous-style, without changing its asynchronous essence. Consider the following JS:</p>
<pre><code class="js"><![CDATA[
    aaa().then(function(x){
        return x.bbb();
    })
    .then(function(x){
        return x.ccc();
    })
    .then(function(x){
        console.log(x);
    });
]]></code></pre>
<p>Now we can write:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        console.log aaa()'wait.bbb()'wait.ccc()'wait
]]></code></pre>
<p>Once the code has <code>'wait</code>, the parent function will be compiled into asynchronous function. We don't need the <code>async</code> keyword, which is totally redundant.</p>
<p><code>'wait</code> must be in a function.</p>
<p><code>'wait</code> is to operate promises. The operand can be a normal promise, or another asynchronous function's return value. The return value of an asynchronous function is also a promise.</p>
<p>Inside an asynchronous function, when executing <code>'wait</code> it will wait until the promise is resolved, then proceed.</p>
<p>An asynchronous function can be called without <code>'wait</code>, if the caller doesn't want to wait for the promise to finish.</p>
<p>An example for using <code>'wait</code> to call an asynchronous function:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
        task()'wait
        console.log "success"
]]></code></pre>
<p>Without using <code>'wait</code>, it can also be called for the same purpose:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            aaa()'wait
            bbb()'wait
            console.log "success"
        task()
]]></code></pre>
<p>Note that if an asynchronous function is called without <code>'wait</code>, then it will return before reaching the first <code>'wait</code> inside the asynchronous function. The following example describes the order:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        task: --
            console.log "stage 1"
            aaa()'wait
            console.log "stage 3"
            bbb()'wait
            console.log "stage 4"
        task()
        console.log "stage 2"
]]></code></pre>
<p>There's one limitation: Because an asynchronous function is compiled into a generator, and the ES6 generator can't contain <code>super</code>, so an asynchronous function can't contain <code>super</code>. It may be solved in later versions, but it requires a huge amount of code to simulate a generator. Surely, it will eventually be solved after ES7 is released, for we can compile it to the native ES7 asynchronous function.</p>
<h1>Object-oriented</h1>
<h2>Class</h2>
<p class="detail">"Field", "member", and "property" are synonyms in this article. A field can be called a "method" if it's a function.</p>
<p>Example:</p>
<pre><code class="fus-part"><![CDATA[
    Cat: class
        new: name ->
            me.name: name
        speak: <>
            console.log me.name + " makes a noise."

    Lion: class from Cat
        speak: <>
            super()
            console.log me.name + " roars."
]]></code></pre>
<p><code>constructor</code> is simplified to <code>new</code>。</p>
<p>JS's <code>this</code> is replaced by <code>me</code>. We also have another keyword <code>Me</code>, where M is in uppercase, meaning the class of <code>me</code>. When a method is called statically, <code>Me</code> is identical to <code>me</code>, but it's recommended to use <code>Me</code> because it looks more like a class.</p>
<p>A highlight of FutureScript's classes is the "anti-conflict field", which is similar to "private field". The benefit of an anti-conflict field is not that the external code can't access it (though can't access it directly by object property). The benefit is that derived classes can safely define a field with the same name, without worrying about the possible conflicts. This is especially important in projects with very complex class structures.</p>
<p>First we look at a negative example. Assuming someone has written a library with an ES6 class in JS:</p>
<pre><code class="js"><![CDATA[
    class User {
        constructor(username) {
            this._name = username;
        }
        getUsername() {
            return this._name;
        }
    }
]]></code></pre>
<p>He has also written an API documentation of how to use <code>User</code>'s constructor and <code>getUsername</code> method. So you write a <code>HumanUser</code> class that inherits <code>User</code> in JS:</p>
<pre><code class="js"><![CDATA[
    class HumanUser extends User {
        constructor(username, name) {
            super();
            this._name = name;
        }
        getName() {
            return this._name;
        }
    }
]]></code></pre>
<p>Because he didn't tell you in documentation which "private fields" he had used, and because your "private field" happens to be <code>_name</code>, your class can't work correctly.</p>
<p>In FutureScript, once a field starts with <code>_</code>, it automatically becomes an anti-conflict field. These 2 classes can be modified as follows in FutureScript:</p>
<pre><code class="fus-part"><![CDATA[
    User: class
        new: username ->
            me._name: username
        getUsername: <>
            me._name
]]></code></pre>
<p>And</p>
<pre><code class="fus-part"><![CDATA[
    HumanUser: class from User
        new: (username, name) ->
            super()
            me._name: name
        getName: <>
            me._name
]]></code></pre>
<p>Why can it avoid conflicts? Because <code>me._name</code> isn't compiled into <code>this._name</code>, but rather compiled into <code>this[_name]</code>, where <code>_name</code> isn't a string but a <code>Symbol</code> instance. Once the compiler goes to <code>me.</code> followed by <code>_</code>, it will compile as such. You can test if you can still access this property using <code>instance._name</code> in JS console.</p>
<p>Anti-conflict fields can also be in the class definition. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Animal: class
        _name: "My Name"
]]></code></pre>
<p>An anti-conflict field can't be enclosed with quotation marks. So, if you want a normal field to start with <code>_</code>, you can write it like <code>me."_name"</code>, therefore it's not an anti-conflict field.</p>
<p>For static fields, we use <code>static</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Car: class
        static wheelCount: 4
        static energy: "gas"
]]></code></pre>
<p>Anti-conflict fields also apply to static fields. Just rename <code>me.</code> to <code>Me.</code>.</p>
<p>Like C#, it also supports "static constructor". Just make <code>static</code> followed by nothing. For example:</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static: <>
            result: longTimeTask()
            Me.part1: result.0
            Me.part2: result.1
        static ok: <> Me.part1'ok
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static ok: <> Me.part1'ok
    result: longTimeTask()
    Website.part1: result.0
    Website.part2: result.1
]]></code></pre>
<p>The benefit of a static constructor is that all class-related code can be held inside the class. This looks nicer, brings less typing, and makes variables unexposed.</p>
<p>In static constructors, <code>me.</code> and <code>Me.</code> both mean the class in the closure (i.e. the class itself), not the class of the current object.</p>
<p>C# programmers will not feel strange about getters and setters. We also support them:</p>
<pre><code class="fus-part"><![CDATA[
    Animal: class
        new: <>
            me._name: @0

        name'get: <>
            me._name.toUpperCase()
        name'set: <>
            me._name: @0
]]></code></pre>
<p>You don't need to use <code>new</code> when creating instances, because JS's <code>new</code> is redundant - a class isn't useful as a normal function. So, in FutureScript, if a function is recognized as a class, then the function call will automatically have <code>new</code> in generated JS. If not, then it won't have <code>new</code>. The detailed logic is specified by the version line. In rare occasions, a function name of a library may violate the good naming conventions, causing it to be recognized as a class. In this case you can use <code>nonew</code> keyword, which has a similar grammar as <code>new</code>.</p>
<p class="detail">JS supports the form of <code>new new a(b)(c)</code>, but we don't support, because it's too unreadable. You can write as <code>new (new a(b))(c)</code>.</p>
<p>As long as there's a use case for instantiating, you should use a capitalized name for a class, otherwise the compiler will be affected. But if all use cases are static, then you can use any name.</p>
<p><code>Number</code>, <code>String</code>, <code>Boolean</code> and <code>Symbol</code> are always recognized as non-classes, regardless of the version line.</p>
<p>FutureScript classes are ES6 classes, not those represented by a function in ES5 or CoffeeScript. So what's the difference? In ES5 or CoffeeScript, <code>super</code> and <code>this</code> could be in arbitrary order in the constructor of a derived class; But in FutureScript (or ES6) in the constructor of a derived class, <code>me</code> or <code>Me</code> can't be used before <code>super</code>. This is stricter, but in fact it's the same as C# and most mainstream languages. Also it makes this possible: to inherit built-in classes like <code>Array</code> and <code>Error</code>, which is impossible in ES5. (But the problem is that so far only Microsoft Edge fully supports inheriting built-in classes, while other browsers and Node.js still just provide partial support. So now, we can do anything except inheriting <code>Array</code> and <code>Error</code>. But considering ES6 was just released in June 2015, things will change in a few months.)</p>
<p>But the grammar of FutureScript's <code>super</code> is like CoffeeScript. You don't need to write <code>super.methodName()</code>. Simply use <code>super()</code>. We don't support CoffeeScript's standalone <code>super</code>, but you can use <code>super'(@)</code>.</p>
<p class="detail">We know that generally a constructor doesn't have a return value. But in fact in JS (including ES6), a constructor can have a return value. The return value can be any object, thus you will create an object that's not an instance of the class. This is weird and useless (because this purpose can be achieved by using a static method). So in FutureScript, although constructors can have return values, they almost don't have any effects. What it creates is always an instance of this class. (The only use of the return value is when using <code>fun</code> in recursion, if you really want to recursively call a constructor.)</p>
<p>Do not assign value to a prototype of another object inside a class. For example, this is unreasonable (though it won't raise error):</p>
<pre><code class="fus-part"><![CDATA[
    Website: class
        static: <>
            Abc.prototype.def: <>
                doSomething()
]]></code></pre>
<p>It's because <code>me</code> is bound to the outer class even in the inner <code>prototype</code> function. The correct way is to write it outside the class. Regarding nested classes, they will work as expected, because the compiler can recognize the <code>class</code> keyword and then interpret <code>me</code> correctly. But nested classes are not very useful. It's suggested that classes be flat.</p>
<h1>Use External Libraries</h1>
<h2>Pipe</h2>
<p>If you have used the library "underscore", you must be familiar with this code:</p>
<pre><code class="js"><![CDATA[
    var _ = require("underscore");
    console.log(_.max(_.map([3, 4, 5], function(x){return x * 2;})));
]]></code></pre>
<p>Pipe operator is <code>|></code>. It can adjust the order to a natural order, so it can be written as:</p>
<pre><code class="fus-part"><![CDATA[
    console.log [3, 4, 5] |> _.map(x -> x * 2) |> _.max
]]></code></pre>
<p>Note, that because of the precedence, you should avoid using space function call in pipe. For example, the above code can't be written as:</p>
<pre><code class="fus-part"><![CDATA[
    console.log [3, 4, 5] |> _.map x -> x * 2 |> _.max
]]></code></pre>
<p>Another operator is <code>::</code>, called "fat dot", used specifically in pipe expressions. If you want to use pipe along with dots, then fat dot brings more readability. For example:</p>
<pre><code class="fus-part"><![CDATA[
    [3, 4, 5] |> _.map(x -> x * 2) :: map(x -> x + 1) |> _.max
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    (([3, 4, 5] |> _.map(x -> x * 2)).map(x -> x + 1)) |> _.max
]]></code></pre>
<p>So basically a fat dot is equal to a normal dot, except that it acts as an ending tag when it's on the right side of the pipe operator. Also, it is as "fat" as the pipe operator, so looks better.</p>
<p>The code using pipe can be in either compatible mode or radical mode. But if an external library is also written in FutureScript, then this external library should better be written in comptatible mode, because the functions in it must take multiple arguments because pipe itself is to split arguments.</p>
<h1>Other features</h1>
<h2>do</h2>
<p><code>do</code> is a shorthand for <code>(...)()</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    do --
        console.log "This will be displayed immediately."
]]></code></pre>
<p>Equivalent to:</p>
<pre><code class="fus-part"><![CDATA[
    (--
        console.log "This will be displayed immediately."
    )()
]]></code></pre>
<p>The features are a little less, but purer than CoffeeScript's <code>do</code>. It can be used to:</p>
<ul>
    <li>Represent a recursion that should run immediately.</li>
    <li>Restrict the scope of a variable to avoid conflicts.</li>
    <li>Wrap code to increase readability.</li>
</ul>
<p>Which CoffeeScript feature is missing in FutureScript? See this CoffeeScript code：</p>
<pre><code class="coffee"><![CDATA[
    for button in buttons
        do (button) ->
            button.onclick = ->
                console.log button.textContent
]]></code></pre>
<p>Using <code>do</code> to "hold" a variable name is not supported, because we strictly prohibit same-name variables in different levels. But now it seems there's no need to support it, because we have a better way:</p>
<pre><code class="fus-part"><![CDATA[
    buttons.forEach button ->
        button.onclick: --
            console.log button.textContent
]]></code></pre>
<p>Or:</p>
<pre><code class="fus-part"><![CDATA[
    buttons.every button ->
        button.onclick: --
            console.log button.textContent
        true
]]></code></pre>
<p>This is where the functional style surpasses loops.</p>
<p>But what's the difference between <code>forEach</code> and <code>every</code>? This is beyond this specification but important so I want to point it out. These 2 are ES5 methods. When using <code>forEach</code>, you can't simulate <code>break</code>. But when using <code>every</code>, you can neatly simulate <code>break</code> - just let it return <code>false</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    range.every i ->
        console.log i
        i < 5 ? true | false
]]></code></pre>
<p>We can also replace the <code>true</code> and <code>false</code> with the shorter <code>1</code> and <code>0</code>:</p>
<pre><code class="fus-part"><![CDATA[
    range.every i ->
        console.log i
        i < 5 ? 1 | 0
]]></code></pre>
<p class="detail">Although <code>do</code> can't hold a variable name like CoffeeScript, you can reach the target by naming it differently:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    do --
        btn: button
        btn.onclick: --
            console.log btn.textContent
]]></code></pre>
<p class="detail">But the problem is that we don't have native loops, so this example is useless.</p>
<p><code>do</code> must be followed by a function literal. This is stricter than CoffeeScript.</p>
<h2>Existence</h2>
<p>These keywords or symbols are about "existence": <code>'ok</code>, <code>ifvoid</code>, <code>ifnull</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a'ok # a !== undefined && a !== null
]]></code></pre>
<p><code>a'ok</code> means <code>a</code> isn't <code>void</code> or <code>null</code>.</p>
<p><code>'ok</code> can be used in combination with dots. For example:</p>
<pre><code class="fus-part"><![CDATA[
    zip: lottery.winner'ok.address'ok.zipcode
]]></code></pre>
<p>If and only if <code>lottery.winner</code> isn't <code>void</code> or <code>null</code> and <code>lottery.winner.address</code> isn't <code>void</code> or <code>null</code>, <code>zip</code> will be <code>lottery.winner.address.zipcode</code>. If any part of the chain is broken, <code>zip</code> will be <code>void</code> without raising errors.</p>
<p><code>ifnull</code> and <code>ifvoid</code> have two forms respectively. One is for expression and the other is for colon assignment. For example:</p>
<pre><code class="fus-part"><![CDATA[
    a ifnull: 8 # if (a === null || a === undefined) {a = 8;}
    a ifvoid: 8 # if (a === undefined) {a = 8;}
    b: a ifvoid 8 # b = a !== undefined ? a : 8;
]]></code></pre>
<p class="detail">When used in colon assignment, for now we don't support they coexist with <code>[...]</code>, <code>,</code> or <code>'export</code>. For example, these are illegal:</p>
<pre class="detail"><code><![CDATA[
    a, b ifnull: 1
    [a, b] ifvoid: [1, 2]
    a'export ifnull: 1
]]></code></pre>
<h2>Variant</h2>
<p>You've already seen many apostrophes. These are called variants. Now let's gather them together.</p>
<p>There are 2 forms: unary <code>'</code> and binary <code>'</code>. Unary <code>'</code> is the function's single-argument variant. Others are all binary <code>'</code>.</p>
<p class="detail">How does the compiler determine if a <code>'</code> is unary or binary? It checks the character immediately after <code>'</code>. If it's a number or letter, it's binary; otherwise (e.g. a symbol, space or nothing at all) it's either unary or a parsing failure.</p>
<p class="detail">So these two are the same:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a'ok
    a 'ok
]]></code></pre>
<p class="detail">But this is different:</p>
<pre class="detail"><code class="fus-part"><![CDATA[
    a' ok
]]></code></pre>
<p class="detail">For readability, a unary<code>'</code> can't be preceded by a space. So this is illegal:</p>
<pre class="detail"><code><![CDATA[
    a ' ok
]]></code></pre>
<p class="detail">A line can't start with <code>'</code>. So this is illegal (but may be illegal in future versions):</p>
<pre class="detail"><code><![CDATA[
    a
    'ok
]]></code></pre>
<p class="detail">For now there can be at most two <code>'</code> before the colon.</p>
<h2>in</h2>
<p><code>in</code> is almost the same as CoffeeScript. Of course we don't support <code>!in</code>, but you can use <code>... not in ...</code> or <code>not ... in ...</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    2 in [1, 2, 3] # returns true
    4 in [1, 2, 3] # returns false
    4 not in [1, 2, 3] # returns true
    not 4 in [1, 2, 3] # returns true
]]></code></pre>
<h2>is</h2>
<p><code>is</code> means the left side is of the right side type, similar to JavaScript's <code>instanceof</code> but a little different. It can also check primitive types. So it's a mix of <code>instanceof</code> and <code>typeof</code>. If the right side is <code>Number</code>, <code>Boolean</code>, <code>String</code> or <code>Symbol</code> (must be verbatim, not a reference), it will use <code>typeof</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a is A # a instanceof A
    a is Number # typeof a === "number"
]]></code></pre>
<p>Similar to <code>in</code>, to negate it you can use <code>not is</code>, but it's recommended to use the good-looking <code>isnt</code>. You can even use <code>is not</code>.</p>
<pre><code class="fus-part"><![CDATA[
    a isnt A
    a not is A
    not a is A
    a is not A
]]></code></pre>
<p>These 4 behaves the same. You might ask if <code>a is not A</code> is ambiguous. No, because <code>a is (not A)</code> is meaningless - a boolean isn't a class.</p>
<h2>delete</h2>
<p><code>delete</code> is a bit different from JS. It's no longer an expression. This is because in JavaScript strict mode <code>delete</code> will never be <code>false</code>, but will instead throw an error. Since we always use strict mode, there's no need to make it an expression.</p>
<h2>rem, mod</h2>
<p><code>rem</code> (remainder) means JS's <code>%</code>. <code>mod</code> is just another modulo operation, where the result has the same sign as the divisor. If the divisor is positive, it's guaranteed that the result is non-negative. So I think <code>mod</code> can be used more widely than <code>rem</code>. <code>a mod b</code> is equivalent to JS's <code>(a % b + b) % b</code>.</p>
<h2>+ and - (as sign)</h2>
<p class="detail">The grammar of the unary <code>+</code> and <code>-</code> (treated as sign) is similar to CoffeeScript with slight difference. We require that it must be followed immediately by an operand. If it's followed by a space then it will be treated as the binary addition and subtraction. For example:</p>
<pre class="detail"><code><![CDATA[
    # a is 5. `-2` can't be connected because it is a valid statement.
    # To connect, either add a space or move the `-` to the first line
    a: 5
    -2

    # a is 5 - 2
    a: 5
    - 2

    a: -1 # valid
    a: - 1 # invalid

    a+b # a + b
    a + b # a + b
    a+ b # a + b
    a +b # a(+b)

    # They are all `a + (-b)`.
    a + (-b)
    a+(-b)
    a + -b
    a+ -b

    a+-b # invalid
    a++b # invalid
]]></code></pre>
<p class="detail">If it's not followed by a space, then if it's preceded by a letter, digit, <code>_</code>, <code>$</code>, <code>)</code>, <code>]</code>, <code>}</code>, <code>"</code> or <code>@</code>, then it will be treated as binary, otherwise unary.</p>
<p class="detail">Also, when treated as an operator, <code>+</code>, <code>-</code>, <code>*</code> or <code>/</code> can't be followed immediately by <code>+</code> or <code>-</code>.</p>
<h2>Debug</h2>
<p>Use <code>pause</code> to insert a breakpoint. It's equivalent to JS's <code>debugger</code>. We renamed it to <code>pause</code> because <code>debugger</code> is longer than 7 characters.</p>
<h2>Insert JavaScript</h2>
<p>Use <code>js"</code>. For example:</p>
<pre><code class="fus-part"><![CDATA[
    hi: js"
        function() {
            return ["Hello", "JavaScript"].join(" ");
        }
    "
]]></code></pre>
<p>It suppresses all features of <code>\</code>. For inline JS, double quotes can't be represented. But you can use apostrophes. If you must use double quotes, use formatted JS like the above example.</p>
<p>To work correctly, the inserted JS must be an expression as a whole, such as JS function expression, JS assignment expression. This acts the same as CoffeeScript.</p>
<p>Because it must be an expression as a whole, the outermost level can't contain semicolons. For example you can write this:</p>
<pre><code class="fus-part"><![CDATA[
    js"
        (function() {
            a = 1;
            b = 2;
        })()
    "
]]></code></pre>
<p>But you can't write this:</p>
<pre><code class="fus-part"><![CDATA[
    js"
        a = 1;
        b = 2;
    "
]]></code></pre>
<h1>All Together</h1>
<h2>Keywords</h2>
<ul style="font-family: monospace;">
    <li>above</li>
    <li>and</li>
    <li>as</li>
    <li>catch</li>
    <li>class</li>
    <li>delete</li>
    <li>do</li>
    <li>else</li>
    <li>export</li>
    <li>false</li>
    <li>finally</li>
    <li>fun</li>
    <li>if</li>
    <li>ifnull</li>
    <li>ifvoid</li>
    <li>import</li>
    <li>in</li>
    <li>is</li>
    <li>isnt</li>
    <li>match</li>
    <li>me</li>
    <li>Me</li>
    <li>mod</li>
    <li>new</li>
    <li>nonew</li>
    <li>not</li>
    <li>null</li>
    <li>or</li>
    <li>pause</li>
    <li>rem</li>
    <li>self</li>
    <li>super</li>
    <li>then</li>
    <li>throw</li>
    <li>true</li>
    <li>try</li>
    <li>void</li>
</ul>
<h2>Naming Restrictions</h2>
<p>A variable name can't be a keyword. A variable name can be a JS keyword (as long as it's not a FutureScript keyword). For example, <code>function</code> and <code>instanceof</code> can be variable names.</p>
<p>In class definition, a property name, if not enclosed with double quotes, can't be <code>new</code> or <code>static</code>. Note that <code>static</code> isn't a keyword. <code>new</code> isn't a keyword in class definition (i.e. followed by a colon).</p>
<p>Object literal's property name doesn't have any restrictions.</p>
<p>Of course, if not enclosed with double quotes, the above names must meet the identifier restriction, that is: each character must be a letter, digit, <code>_</code> or <code>$</code>, and it doesn't start with a digit.</p>
<h2>Symbols</h2>
<ul style="font-family: monospace;">
    <li>-&gt;</li>
    <li>&lt;&gt;</li>
    <li>--</li>
    <li>:</li>
    <li>(</li>
    <li>)</li>
    <li>.</li>
    <li>[</li>
    <li>]</li>
    <li>{</li>
    <li>}</li>
    <li>#</li>
    <li>###</li>
    <li>"</li>
    <li>v"</li>
    <li>r"</li>
    <li>js"</li>
    <li>,</li>
    <li>@</li>
    <li>+</li>
    <li>-</li>
    <li>*</li>
    <li>/</li>
    <li>**</li>
    <li>=</li>
    <li>/=</li>
    <li>&lt;</li>
    <li>&gt;</li>
    <li>&lt;=</li>
    <li>&gt;=</li>
    <li>|&gt;</li>
    <li>?</li>
    <li>;</li>
    <li>::</li>
    <li>|</li>
    <li>'</li>
    <li>\</li>
    <li>\(</li>
    <li>'wait</li>
    <li>'ok</li>
    <li>'get</li>
    <li>'set</li>
    <li>'export</li>
    <li>&lt;&lt;</li>
    <li>&gt;&gt;</li>
</ul>
<h2>Operator Precedence</h2>
<p class="detail">The result of an operation is an expression, but an operator isn't always an expression. It can be a block or a non-value thing. Not all operators have precedence. Those whose operands must occupy all the remaining area of the line (unless using <code>&lt;&lt;</code> and <code>&gt;&gt;</code>) don't have precedence, for example <code>match</code> and <code>class</code>. Postfixed <code>if</code> also doesn't have precedence. In the following table, <code>a</code>, <code>b</code>, <code>c</code> mean expression operands; <code>m</code>, <code>n</code> mean block operands; <code>x</code>, <code>y</code>, <code>z</code> mean operands that's not always expressions or blocks.</p>
<p>Note: Precedence is ordered from lowest to highest. In references of other languages they are all from highest to lowest, but I think it's improper for this language because from the functional (recursive) point of view, it should be from "big" (low) to "small" (high). As for associativity, we are also opposite to the traditional way. The traditional table shows the order of execution, but our table shows the order of parsing (to be more accurate, parsing recursively). That is: If executed from left to right, because the right side is "bigger", it's defined as from right to left, simplified as "right"; If executed from right to left, because the left side is "bigger", it's defined as from left to right, simplified as "left". For example, <code>1 + 2 + 3</code> is parsed as <code>plus(plus(1, 2), 3)</code>, and the bigger is shown first. In brief, you can just think we show everything in reverse order in the table.</p>
<table class="table">
    <tr>
        <th>Precedence</th>
        <th>Operator type</th>
        <th>Examples</th>
    </tr>
    <tr>
        <td rowspan="3">0 left</td>
        <td>Arrow Function</td>
        <td><code>x -&gt; m</code></td>
    </tr>
    <tr>
        <td>Diamond Function</td>
        <td><code>&lt;&gt; m</code></td>
    </tr>
    <tr>
        <td>Dash Function</td>
        <td><code>-- m</code></td>
    </tr>
    <tr>
        <td>1 left</td>
        <td>Conditional</td>
        <td><code>if a then m else n<br/>a ? m | n</code></td>
    </tr>
    <tr>
        <td rowspan="3">2 left</td>
        <td>Space Function Call</td>
        <td><code>a b</code></td>
    </tr>
    <tr>
        <td>Space new</td>
        <td><code>new a b</code></td>
    </tr>
    <tr>
        <td>Space nonew</td>
        <td><code>nonew a b</code></td>
    </tr>
    <tr>
        <td>3 right</td>
        <td>or</td>
        <td><code>a or b</code></td>
    </tr>
    <tr>
        <td>4 right</td>
        <td>and</td>
        <td><code>a and b</code></td>
    </tr>
    <tr>
        <td>5 left</td>
        <td>not</td>
        <td><code>not a</code></td>
    </tr>
    <tr>
        <td rowspan="6">6 right</td>
        <td>Equality</td>
        <td><code>a = b</code></td>
    </tr>
    <tr>
        <td>Inequality</td>
        <td><code>a /= b</code></td>
    </tr>
    <tr>
        <td>Less Than</td>
        <td><code>a &lt; b</code></td>
    </tr>
    <tr>
        <td>Less Than Or Equal</td>
        <td><code>a &lt;= b</code></td>
    </tr>
    <tr>
        <td>Greater Than</td>
        <td><code>a &gt; b</code></td>
    </tr>
    <tr>
        <td>Greater Than Or Equal</td>
        <td><code>a &gt;= b</code></td>
    </tr>
    <tr>
        <td rowspan="4">7 right</td>
        <td>in</td>
        <td><code>a in b</code></td>
    </tr>
    <tr>
        <td>Negative in</td>
        <td><code>a not in b</code></td>
    </tr>
    <tr>
        <td>is</td>
        <td><code>a is b</code></td>
    </tr>
    <tr>
        <td>Negative is</td>
        <td><code>a isnt b</code></td>
    </tr>
    <tr>
        <td rowspan="2">8 right</td>
        <td>Addition</td>
        <td><code>a + b</code></td>
    </tr>
    <tr>
        <td>Subtraction</td>
        <td><code>a - b</code></td>
    </tr>
    <tr>
        <td rowspan="4">9 right</td>
        <td>Multiplication</td>
        <td><code>a * b</code></td>
    </tr>
    <tr>
        <td>Division</td>
        <td><code>a / b</code></td>
    </tr>
    <tr>
        <td>Remainder</td>
        <td><code>a rem b</code></td>
    </tr>
    <tr>
        <td>Modulo</td>
        <td><code>a mod b</code></td>
    </tr>
    <tr>
        <td>10 left</td>
        <td>Exponentiation</td>
        <td><code>a ** b</code></td>
    </tr>
    <tr>
        <td rowspan="2">11 left</td>
        <td>Unary Plus</td>
        <td><code>+a</code></td>
    </tr>
    <tr>
        <td>Unary Negation</td>
        <td><code>-a</code></td>
    </tr>
    <tr>
        <td rowspan="2">12 right</td>
        <td>ifvoid</td>
        <td><code>a ifvoid b</code></td>
    </tr>
    <tr>
        <td>ifnull</td>
        <td><code>a ifnull b</code></td>
    </tr>
    <tr>
        <td rowspan="2">13 right</td>
        <td>as</td>
        <td><code>a as x</code></td>
    </tr>
    <tr>
        <td>export as</td>
        <td><code>a export as x</code></td>
    </tr>
    <tr>
        <td>14 right</td>
        <td>Pipe</td>
        <td><code>a |&gt; b</code></td>
    </tr>
    <tr>
        <td rowspan="8">15 right</td>
        <td>Member Access</td>
        <td><code>a.x<br/>a."x"<br/>a.(b)</code></td>
    </tr>
    <tr>
        <td>Fat Dot Member Access</td>
        <td><code>a :: x</code></td>
    </tr>
    <tr>
        <td>Function Call</td>
        <td><code>a(b)<br/>a[b]<br/>a{x}</code></td>
    </tr>
    <tr>
        <td>new</td>
        <td><code>new a(b)</code></td>
    </tr>
    <tr>
        <td>nonew</td>
        <td><code>nonew a(b)</code></td>
    </tr>
    <tr>
        <td>Variant</td>
        <td><code>a'x</code></td>
    </tr>
    <tr>
        <td>Function Variant</td>
        <td><code>a'</code></td>
    </tr>
    <tr>
        <td>import</td>
        <td><code>import "x"</code></td>
    </tr>
</table>
<h2>FAQ</h2>
<p class="question">Q: CoffeeScript has <code>return</code>, but FutureScript goes so far as to drop the <code>return</code>?</p>
<p>A: <code>return</code> is a jump statement, which functional style should avoid. Many functional languages, like F#, don't have <code>return</code>. F# has loops, but doesn't have the <code>break</code> statement that can jump out of the loop. Just like that people all think C's <code>goto</code> is evil because <code>goto</code> is jumping. Although <code>return</code> is only able to jump out, not jump freely, so it's not as evil as <code>goto</code>, but I think it's better to be pure in the beginning period of FutureScript. In fact it's very easy to reach the same target. For example you want to write:</p>
<pre><code><![CDATA[
    x ->
        if x isnt Number return
        x * 2
]]></code></pre>
<p>But now you can write:</p>
<pre><code class="fus-part"><![CDATA[
    x ->
        if x isnt Number
            void
        else
            x * 2
]]></code></pre>
<p>If you don't like more lines, you can write:</p>
<pre><code class="fus-part"><![CDATA[
    x ->
        x isnt Number ? void |
            x * 2
]]></code></pre>
<p>The benefit of this way is that the structure is clearer. As long as it doesn't throw error, the exit of the function is always one: the bottom.</p>
<p class="question">问：为啥没有位操作符？</p>
<p>答：首先，FutureScript作为高级语言，没必要支持。其次，JavaScript的位操作是专门针对32位数字的，这本身就不合理。</p>
<p class="question">问：为啥没有生成器？</p>
<p>答：生成器是适合特定用途的，似乎普适性还不够。至于缩短代码长度？加一个类库也可以达到这个目的，干嘛非得改动语言层面呢？至于在异步操作中的用途，FutureScript也已经有了更好的替代方法。</p>
<p class="question">问：为啥格式字符串的缩进必须大于引号处的缩进？等于也不行吗？</p>
<p>答：如果允许等于或小于，就有可能造成编译器误判，当字符串中某行行首正好是引号的时候。</p>
<p class="question">问：为啥函数除了箭头符号以外还要弄个菱形符号？</p>
<p>答：我的目标是消除CoffeeScript中参数两边的括号。但是如果没有括号的话会产生歧义。所以我就想出了这个办法，如果不加括号，那就必须为1个参数。那零个参数怎么办？就再造一个符号呗。至于多个参数，就必须加括号，不过多参数并不在我的理想化（即激进模式）的构想当中，所以这也可以接受。再有一个原因，就是CoffeeScript用箭头表示零参数的话看上去既别扭又误导，箭头嘛，感觉应该左边有东西才对。</p>
<p class="question">问：既然如此，那为啥激进模式不废除箭头符号？反正有<code>@</code>可以用。</p>
<p>答：激进模式中，大多数情况下确实没必要给参数取名，但当你有多层函数，内层调用外层参数的时候，取名就有必要了。</p>
<p class="question">问：为啥没有保留字？</p>
<p>答：很多语言都有很多保留字，但我觉得你设计语言的时候预先定义好未来的功能，那未来有可能是你没料到的。我们在版本行使用版本号，也达到了“安全”的目的，因为可以保证只要你不修改版本号，就不会出现兼容性问题。</p>
<p class="question">问：不支持<code>var</code>是受CoffeeScript启发，但为啥不支持ES6的<code>let</code>和<code>const</code>？</p>
<p>答：我的理念是，一名程序员也许不熟悉正在开发的文件之外的其他文件，但是一般都会熟悉这个文件当中的其他区域。<code>let</code>提供块级的保护，但是只要你熟悉的不是只是这个块，你完全可以使用一个不同的变量名。块级保护太小了，函数级保护已经足够坚固。否则的话语言本身的复杂度也会增加。<code>let</code>和CoffeeScript风格之间也有矛盾。而且我们是编译成<code>var</code>，曾经我想把所有变量编译成<code>let</code>，但是考虑这样的代码：</p>
<pre><code class="fus-part"><![CDATA[
    if x > 0
        a: 1
        b: 2
        c: 3
    else
        a: 4
        b: 5
        c: 6
    console.log(a + b + c)
]]></code></pre>
<p>如果是编译成<code>let</code>，那么这段代码是有错的，必须要在顶部给<code>a</code>、<code>b</code>、<code>c</code>赋值才行。所以我觉得还是编译成<code>var</code>好。</p>
<p>至于<code>const</code>，我觉得理念有问题，<code>const</code>只是针对常量而已，而我们让某个东西不可变，不是防自己改，是防别人改。通常是自己做了个库，别人使用时，在运行时可能会乱改内部逻辑。变量仅自己可见，别人改不了，又何必成为常量？真正要保护的其实是对象的属性或方法，这个<code>const</code>却无法做到。可以通过<code>Object.defineProperty</code>来做到。但要动就得动包括原生对象在内的所有的对象，让方法都变得坚固（即变成类似静态语言的样子），这工作量太大了，可行性也值得怀疑，所以目前暂不做。</p>
<p class="question">问：为何不支持对象解构赋值和复杂数组的解构赋值？</p>
<p>答：对象解构赋值过于复杂。它符合了人类一部分直觉，但违反了人类另一部分直觉，导致一开始根本就看不懂。复杂数组的解构赋值是中等复杂，以后也许会支持。至于对象解构赋值，以后即使支持，语法也要改得更自然。</p>
<p class="question">问：为什么arguments用<code>@</code>表示？</p>
<p>答：首先，<code>@</code>形状也像个a。其次，<code>@</code>是符号中看上去最不像符号的，我们经常会使用孤立的<code>@</code>作为一个表达式，这时如果用其他符号，会显得不像个表达式，就不舒服了。</p>
<p class="question">问：为什么以多参数调用函数一定要加括号？CoffeeScript不是可以不加吗？</p>
<p>答：多参数要用到逗号，不加括号的话，逗号到底分隔什么，不容易看清楚，大多数时候违反人类直觉。而且，现在默认是兼容模式，但因为我觉得激进模式更完美，如果多参数可以不加括号，就显得更加鼓励人们采用兼容模式了。</p>
<p class="question">问：<code>@</code>很好用，如果catch的上下文也能用一个符号表示就好了。</p>
<p>答：本来我考虑再用个新的符号来指代子语句内的上下文，不仅限于catch，但想想，不宜。用<code>@</code>时你很容易看清某个<code>@</code>所对应的是哪个函数，因为函数符号很好辨认。但子语句仅有的特征是缩进，而缩进我们是用得非常多的，很容易这个新符号的意思会变来变去，导致你搞混。如果这个新符号仅限于catch，又适用面太小。</p>
<p class="question">问：<code>as</code>为何不能用逗号同时赋值？</p>
<p>答：若支持，像这个表达式<code>[aaa as a, bbb]</code>就容易产生歧义。</p>
<p class="question">问：保留旧版本的编译器，那岂不越来越庞大？好恐怖！</p>
<p>答：其实也没那么恐怖，我们在做FutureScript的时候会采取一些手段，使增量不那么大。</p>
<p class="question">问：真的所有旧版本的编译器都包括吗？</p>
<p>答：我们尽量包括。但如果我们发现某个旧版本有安全漏洞，那么我们则会删掉。若不存在与代码相同版本的编译器，编译的时候会出现警告，同时会自动用新版本的编译器编译。</p>
<p class="question">问：CoffeeScript多行链式（chaining）方法调用不用加括号，这里为啥要加括号？</p>
<p>答：CoffeeScript其实是硬生生加了条规则，这会破坏语法的统一，而且虽然在一部分需求中更简洁了，但当有另一部分需求的时候却更复杂了。所以我决定不用这套方法。</p>
<p class="question">问：为啥一个模块既有“默认导出”又有“命名导出”不好？</p>
<p>答：你完全可以分两个模块，或者给“默认导出”取个非default的名字（事实上“默认导出”的确是“命名导出”的一部分，名字是default）。</p>
<p class="question">问：为啥<code>-&gt;</code>函数没有定义<code>@</code>？</p>
<p>答：当你参数有名称时，再用<code>@</code>就显得多余。这时用<code>@</code>唯一的作用就是当函数的参数数量可变时。但是如果你的函数参数数量可变，更好的做法是不设任何形参。也有一种情况是希望后半部分参数数量可变，但是我不太喜欢这样做，我建议把这部分参数弄成一个数组。</p>
<p class="question">问：JS中可以用<code>typeof a === "undefined"</code>检查变量是否已定义又不引发异常，这里为啥做不到？</p>
<p>答：这好像并没有什么用。FutureScript的变量统统编译成在函数顶部声明，所以变量的定义与否不是动态的，所以检查这个不应该是程序运行时做的事情。</p>
<p class="question">问：为啥幂运算符<code>**</code>的优先级和CoffeeScript不一样？</p>
<p>答：虽然和CoffeeScript不一样，但是和大多数有这个运算符的语言一样，比如F#，比如未来的ES7草案。CoffeeScript应该是考虑到<code>-3 ** 2</code>如果书写成-3<sup>2</sup>应该是-9，但这看上去非常别扭，除非你加个空格，成为<code>- 3 ** 2</code>，或者干脆都不用空格，成为<code>-3**2</code>，但很少有人会这么写，前者还和多行连接有冲突。另一个原因是，CoffeeScript这样做弄得不大协调，就<code>**</code>显得那么特殊，其实<code>*</code>的优先级理应只比<code>**</code>低一级，只不过<code>(-a) * b</code>恒等于<code>-(a * b)</code>，所以可能他们觉得无所谓就不调整了而已。</p>
<p class="question">问：<code>not</code>优先级被大幅降低，这合理吗？</p>
<p>答：这看上去更自然，更符合人类阅读方式。我承认，这个改变从来没有人做过，具有冒险性。为了看看有没有反例，支持<code>not</code>应该维持目前通用的优先级，我看了GitHub的Atom编辑器的源代码（它是用CoffeeScript编写的），还看了我自己的代码。我发现，几乎没有一处<code>not</code>在目前通用的优先级下更简单的，这给了我信心。因为我的想法是，算术运算符，像加法、乘法，对它们的算元使用<code>not</code>是非常不好的，也许有人会利用这种方式来取巧，但可读性非常差，所以好的代码中是不会出现<code>not a + not b</code>的，这种反例不应该使用。引申到<code>=</code>、<code>&lt;</code>、<code>&gt;</code>也是一样。</p>
<p class="question">问：为啥格式注释是用<code>###</code>？如果像格式字符串一样，不是更简洁吗？</p>
<p>答：有时我们喜欢用注释把一段代码作废，就不可能弄得很整齐。</p>
<p class="question">问：如果<code>export {abc}</code>表示命名导出，<code>export abc</code>表示默认导出不是很好嘛？</p>
<p>答：原先是有这种考虑，但这在将来版本中可能会产生歧义（将来版本中<code>{abc}</code>可能是一个合法的对象）。</p>
<p class="question">问：为啥不支持Unicode变量名（不用引号时）？</p>
<p>答：很少有这种需求，因为加上引号就可以了。不过以后版本中可能会支持。</p>
<p class="question">问：above关键字有啥用？</p>
<p>答：above关键字本来是用来帮助你看清某些特殊形式的代码，但后来我决定在将来版本中再支持这种“特殊形式的代码”，所以above现在没有任何作用。</p>
</body>
</html>
